import{h as ye}from"./assets/htmx.min-BDSWTZMZ.js";const or=e=>t=>{const n=e(t);return t.add(n),n},ar=e=>(t,n)=>(e.set(t,n),n),St=Number.MAX_SAFE_INTEGER===void 0?9007199254740991:Number.MAX_SAFE_INTEGER,nn=536870912,Lt=nn*2,ir=(e,t)=>n=>{const r=t.get(n);let s=r===void 0?n.size:r<Lt?r+1:0;if(!n.has(s))return e(n,s);if(n.size<nn){for(;n.has(s);)s=Math.floor(Math.random()*Lt);return e(n,s)}if(n.size>St)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;n.has(s);)s=Math.floor(Math.random()*St);return e(n,s)},rn=new WeakMap,cr=ar(rn),ft=ir(cr,rn),Ut=or(ft),ur=e=>typeof e.start=="function",Pt=new WeakMap,lr=e=>({...e,connect:({call:t})=>async()=>{const{port1:n,port2:r}=new MessageChannel,s=await t("connect",{port:n},[n]);return Pt.set(r,s),r},disconnect:({call:t})=>async n=>{const r=Pt.get(n);if(r===void 0)throw new Error("The given port is not connected.");await t("disconnect",{portId:r})},isSupported:({call:t})=>()=>t("isSupported")}),Qe=new WeakMap,dr=e=>{if(Qe.has(e))return Qe.get(e);const t=new Map;return Qe.set(e,t),t},sn=e=>{const t=lr(e);return n=>{const r=dr(n);n.addEventListener("message",({data:c})=>{const{id:i}=c;if(i!==null&&r.has(i)){const{reject:u,resolve:d}=r.get(i);r.delete(i),c.error===void 0?d(c.result):u(new Error(c.error.message))}}),ur(n)&&n.start();const s=(c,i=null,u=[])=>new Promise((d,l)=>{const m=ft(r);r.set(m,{reject:l,resolve:d}),i===null?n.postMessage({id:m,method:c},u):n.postMessage({id:m,method:c,params:i},u)}),o=(c,i,u=[])=>{n.postMessage({id:null,method:c,params:i},u)};let a={};for(const[c,i]of Object.entries(t))a={...a,[c]:i({call:s,notify:o})};return{...a}}},Ke=new Set,Bt=new Set,Ee=new WeakMap,fr=sn({deregister:({call:e})=>async t=>{const n=Ee.get(t);if(n===void 0)throw new Error("There is no encoder registered with the given port.");const r=await e("deregister",{encoderId:n});return Ke.delete(n),Ee.delete(t),r},encode:({call:e})=>async(t,n)=>{const r=await e("encode",{encoderInstanceId:t,timeslice:n});return Bt.delete(t),r},instantiate:({call:e})=>async(t,n)=>{const r=Ut(Bt),s=await e("instantiate",{encoderInstanceId:r,mimeType:t,sampleRate:n});return{encoderInstanceId:r,port:s}},register:({call:e})=>async t=>{if(Ee.has(t))throw new Error("");const n=Ut(Ke);Ee.set(t,n);try{return await e("register",{encoderId:n,port:t},[t])}catch(r){throw Ke.delete(n),Ee.delete(t),r}}}),hr=e=>{const t=new Worker(e);return fr(t)},pr=`(()=>{var e={455:function(e,t){!function(e){"use strict";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),c=void 0===a?r.size:a<s?a+1:0;if(!r.has(c))return e(r,c);if(r.size<o){for(;r.has(c);)c=Math.floor(Math.random()*s);return e(r,c)}if(r.size>n)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;r.has(c);)c=Math.floor(Math.random()*n);return e(r,c)}},c=new WeakMap,i=r(c),l=a(i,c),d=t(l);e.addUniqueNumber=d,e.generateUniqueNumber=l}(t)}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{"use strict";var e=r(455);const t=new WeakMap,n=new WeakMap,o=(r=>{const o=(s=r,{...s,connect:e=>{let{call:r}=e;return async()=>{const{port1:e,port2:n}=new MessageChannel,o=await r("connect",{port:e},[e]);return t.set(n,o),n}},disconnect:e=>{let{call:r}=e;return async e=>{const n=t.get(e);if(void 0===n)throw new Error("The given port is not connected.");await r("disconnect",{portId:n})}},isSupported:e=>{let{call:t}=e;return()=>t("isSupported")}});var s;return t=>{const r=(e=>{if(n.has(e))return n.get(e);const t=new Map;return n.set(e,t),t})(t);t.addEventListener("message",(e=>{let{data:t}=e;const{id:n}=t;if(null!==n&&r.has(n)){const{reject:e,resolve:o}=r.get(n);r.delete(n),void 0===t.error?o(t.result):e(new Error(t.error.message))}})),(e=>"function"==typeof e.start)(t)&&t.start();const s=function(n){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return new Promise(((a,c)=>{const i=(0,e.generateUniqueNumber)(r);r.set(i,{reject:c,resolve:a}),null===o?t.postMessage({id:i,method:n},s):t.postMessage({id:i,method:n,params:o},s)}))},a=function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];t.postMessage({id:null,method:e,params:r},n)};let c={};for(const[e,t]of Object.entries(o))c={...c,[e]:t({call:s,notify:a})};return{...c}}})({characterize:e=>{let{call:t}=e;return()=>t("characterize")},encode:e=>{let{call:t}=e;return(e,r)=>t("encode",{recordingId:e,timeslice:r})},record:e=>{let{call:t}=e;return async(e,r,n)=>{await t("record",{recordingId:e,sampleRate:r,typedArrays:n},n.map((e=>{let{buffer:t}=e;return t})))}}}),s=-32603,a=-32602,c=-32601,i=(e,t)=>Object.assign(new Error(e),{status:t}),l=e=>i('The handler of the method called "'.concat(e,'" returned an unexpected result.'),s),d=(e,t)=>async r=>{let{data:{id:n,method:o,params:a}}=r;const d=t[o];try{if(void 0===d)throw(e=>i('The requested method called "'.concat(e,'" is not supported.'),c))(o);const t=void 0===a?d():d(a);if(void 0===t)throw(e=>i('The handler of the method called "'.concat(e,'" returned no required result.'),s))(o);const r=t instanceof Promise?await t:t;if(null===n){if(void 0!==r.result)throw l(o)}else{if(void 0===r.result)throw l(o);const{result:t,transferables:s=[]}=r;e.postMessage({id:n,result:t},s)}}catch(t){const{message:r,status:o=-32603}=t;e.postMessage({error:{code:o,message:r},id:n})}},u=new Map,h=(t,r,n)=>({...r,connect:n=>{let{port:o}=n;o.start();const s=t(o,r),a=(0,e.generateUniqueNumber)(u);return u.set(a,(()=>{s(),o.close(),u.delete(a)})),{result:a}},disconnect:e=>{let{portId:t}=e;const r=u.get(t);if(void 0===r)throw(e=>i('The specified parameter called "portId" with the given value "'.concat(e,'" does not identify a port connected to this worker.'),a))(t);return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),f=function(e,t){const r=h(f,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0),n=d(e,r);return e.addEventListener("message",n),()=>e.removeEventListener("message",n)},w=e=>{e.onmessage=null,e.close()},p=new Map,g=new Map,m=((e,t)=>r=>{const n=t.get(r);if(void 0===n)throw new Error("There was no encoder stored with the given id.");e.delete(n),t.delete(r)})(p,g),v=new Map,y=(e=>t=>{const r=e.get(t);if(void 0===r)throw new Error("There was no instance of an encoder stored with the given id.");return r})(v),M=((e,t)=>r=>{const n=t(r);return e.delete(r),n})(v,y),E=((e,t)=>r=>{const[n,o,s,a]=t(r);return s?new Promise((t=>{o.onmessage=s=>{let{data:c}=s;0===c.length?(e(o),t(n.encode(r,null))):n.record(r,a,c)}})):n.encode(r,null)})(w,M),b=(e=>t=>{for(const[r,n]of Array.from(e.values()))if(r.test(t))return n;throw new Error("There is no encoder registered which could handle the given mimeType.")})(p),T=((e,t,r)=>(n,o,s)=>{if(t.has(n))throw new Error('There is already an encoder instance registered with an id called "'.concat(n,'".'));const a=r(o),{port1:c,port2:i}=new MessageChannel,l=[a,c,!0,s];return t.set(n,l),c.onmessage=t=>{let{data:r}=t;0===r.length?(e(c),l[2]=!1):a.record(n,s,r.map((e=>"number"==typeof e?new Float32Array(e):e)))},i})(w,v,b),I=((e,t,r)=>async(n,o)=>{const s=r(o),a=await s.characterize(),c=a.toString();if(e.has(c))throw new Error("There is already an encoder stored which handles exactly the same mime types.");if(t.has(n))throw new Error('There is already an encoder registered with an id called "'.concat(n,'".'));return e.set(c,[a,s]),t.set(n,c),a})(p,g,o),A=(e=>(t,r)=>{const[n]=e(t);return n.encode(t,r)})(y);f(self,{deregister:async e=>{let{encoderId:t}=e;return m(t),{result:null}},encode:async e=>{let{encoderInstanceId:t,timeslice:r}=e;const n=null===r?await E(t):await A(t,r);return{result:n,transferables:n}},instantiate:e=>{let{encoderInstanceId:t,mimeType:r,sampleRate:n}=e;const o=T(t,r,n);return{result:o,transferables:[o]}},register:async e=>{let{encoderId:t,port:r}=e;return{result:await I(t,r)}}})})()})();`,mr=new Blob([pr],{type:"application/javascript; charset=utf-8"}),on=URL.createObjectURL(mr),ht=hr(on),Le=ht.encode,an=ht.instantiate,gr=ht.register;URL.revokeObjectURL(on);const wr=e=>(t,n)=>{if(e===null)throw new Error("A native BlobEvent could not be created.");return new e(t,n)},vr=(e,t)=>(n,r,s)=>{const o=[];let a=r,c=0;for(;c<n.byteLength;)if(a===null){const i=t(n,c);if(i===null)break;const{length:u,type:d}=i;a=d,c+=u}else{const i=e(n,c,a,s);if(i===null)break;const{content:u,length:d}=i;a=null,c+=d,u!==null&&o.push(u)}return{contents:o,currentElementType:a,offset:c}},_r=(e,t)=>class{constructor(r=null){this._listeners=new WeakMap,this._nativeEventTarget=r===null?e():r}addEventListener(r,s,o){if(s!==null){let a=this._listeners.get(s);a===void 0&&(a=t(this,s),typeof s=="function"&&this._listeners.set(s,a)),this._nativeEventTarget.addEventListener(r,a,o)}}dispatchEvent(r){return this._nativeEventTarget.dispatchEvent(r)}removeEventListener(r,s,o){const a=s===null?void 0:this._listeners.get(s);this._nativeEventTarget.removeEventListener(r,a===void 0?null:a,o)}},yr=e=>()=>{if(e===null)throw new Error("A native EventTarget could not be created.");return e.document.createElement("p")},Er=(e="")=>{try{return new DOMException(e,"InvalidModificationError")}catch(t){return t.code=13,t.message=e,t.name="InvalidModificationError",t}},br=()=>{try{return new DOMException("","InvalidStateError")}catch(e){return e.code=11,e.name="InvalidStateError",e}},Ar=(e,t,n,r,s,o,a)=>class extends o{constructor(i,u={}){const{mimeType:d}=u;if(a!==null&&(d===void 0||a.isTypeSupported!==void 0&&a.isTypeSupported(d))){const l=e(a,i,u);super(l),this._internalMediaRecorder=l}else if(d!==void 0&&s.some(l=>l.test(d)))super(),a!==null&&a.isTypeSupported!==void 0&&a.isTypeSupported("audio/webm;codecs=pcm")?this._internalMediaRecorder=r(this,a,i,d):this._internalMediaRecorder=n(this,i,d);else throw a!==null&&e(a,i,u),t();this._ondataavailable=null,this._onerror=null,this._onpause=null,this._onresume=null,this._onstart=null,this._onstop=null}get mimeType(){return this._internalMediaRecorder.mimeType}get ondataavailable(){return this._ondataavailable===null?this._ondataavailable:this._ondataavailable[0]}set ondataavailable(i){if(this._ondataavailable!==null&&this.removeEventListener("dataavailable",this._ondataavailable[1]),typeof i=="function"){const u=i.bind(this);this.addEventListener("dataavailable",u),this._ondataavailable=[i,u]}else this._ondataavailable=null}get onerror(){return this._onerror===null?this._onerror:this._onerror[0]}set onerror(i){if(this._onerror!==null&&this.removeEventListener("error",this._onerror[1]),typeof i=="function"){const u=i.bind(this);this.addEventListener("error",u),this._onerror=[i,u]}else this._onerror=null}get onpause(){return this._onpause===null?this._onpause:this._onpause[0]}set onpause(i){if(this._onpause!==null&&this.removeEventListener("pause",this._onpause[1]),typeof i=="function"){const u=i.bind(this);this.addEventListener("pause",u),this._onpause=[i,u]}else this._onpause=null}get onresume(){return this._onresume===null?this._onresume:this._onresume[0]}set onresume(i){if(this._onresume!==null&&this.removeEventListener("resume",this._onresume[1]),typeof i=="function"){const u=i.bind(this);this.addEventListener("resume",u),this._onresume=[i,u]}else this._onresume=null}get onstart(){return this._onstart===null?this._onstart:this._onstart[0]}set onstart(i){if(this._onstart!==null&&this.removeEventListener("start",this._onstart[1]),typeof i=="function"){const u=i.bind(this);this.addEventListener("start",u),this._onstart=[i,u]}else this._onstart=null}get onstop(){return this._onstop===null?this._onstop:this._onstop[0]}set onstop(i){if(this._onstop!==null&&this.removeEventListener("stop",this._onstop[1]),typeof i=="function"){const u=i.bind(this);this.addEventListener("stop",u),this._onstop=[i,u]}else this._onstop=null}get state(){return this._internalMediaRecorder.state}pause(){return this._internalMediaRecorder.pause()}resume(){return this._internalMediaRecorder.resume()}start(i){return this._internalMediaRecorder.start(i)}stop(){return this._internalMediaRecorder.stop()}static isTypeSupported(i){return a!==null&&a.isTypeSupported!==void 0&&a.isTypeSupported(i)||s.some(u=>u.test(i))}},Cr=e=>e!==null&&e.BlobEvent!==void 0?e.BlobEvent:null,Tr=e=>e===null||e.MediaRecorder===void 0?null:e.MediaRecorder,Mr=e=>(t,n,r)=>{const s=new Map,o=new WeakMap,a=new WeakMap,c=[],i=new t(n,r),u=new WeakMap;return i.addEventListener("stop",({isTrusted:d})=>{d&&setTimeout(()=>c.shift())}),i.addEventListener=(d=>(l,m,w)=>{let p=m;if(typeof m=="function")if(l==="dataavailable"){const f=[];p=g=>{const[[h,A]=[!1,!1]]=c;h&&!A?f.push(g):m.call(i,g)},s.set(m,f),o.set(m,p)}else l==="error"?(p=f=>{f instanceof ErrorEvent?m.call(i,f):m.call(i,new ErrorEvent("error",{error:f.error}))},a.set(m,p)):l==="stop"&&(p=f=>{for(const[g,h]of s.entries())if(h.length>0){const[A]=h;h.length>1&&Object.defineProperty(A,"data",{value:new Blob(h.map(({data:v})=>v),{type:A.data.type})}),h.length=0,g.call(i,A)}m.call(i,f)},u.set(m,p));return d.call(i,l,p,w)})(i.addEventListener),i.removeEventListener=(d=>(l,m,w)=>{let p=m;if(typeof m=="function"){if(l==="dataavailable"){s.delete(m);const f=o.get(m);f!==void 0&&(p=f)}else if(l==="error"){const f=a.get(m);f!==void 0&&(p=f)}else if(l==="stop"){const f=u.get(m);f!==void 0&&(p=f)}}return d.call(i,l,p,w)})(i.removeEventListener),i.start=(d=>l=>{if(r.mimeType!==void 0&&r.mimeType.startsWith("audio/")&&n.getVideoTracks().length>0)throw e();return i.state==="inactive"&&c.push([l!==void 0,!0]),l===void 0?d.call(i):d.call(i,l)})(i.start),i.stop=(d=>()=>{i.state!=="inactive"&&(c[0][1]=!1),d.call(i)})(i.stop),i},tt=()=>{try{return new DOMException("","NotSupportedError")}catch(e){return e.code=9,e.name="NotSupportedError",e}},Nr=e=>(t,n,r,s=2)=>{const o=e(t,n);if(o===null)return o;const{length:a,value:c}=o;if(r==="master")return{content:null,length:a};if(n+a+c>t.byteLength)return null;if(r==="binary"){const i=(c/Float32Array.BYTES_PER_ELEMENT-1)/s,u=Array.from({length:s},()=>new Float32Array(i));for(let d=0;d<i;d+=1){const l=d*s+1;for(let m=0;m<s;m+=1)u[m][d]=t.getFloat32(n+a+(l+m)*Float32Array.BYTES_PER_ELEMENT,!0)}return{content:u,length:a+c}}return{content:null,length:a+c}},Rr=e=>(t,n)=>{const r=e(t,n);if(r===null)return r;const{length:s,value:o}=r;return o===35?{length:s,type:"binary"}:o===46||o===97||o===88713574||o===106212971||o===139690087||o===172351395||o===256095861?{length:s,type:"master"}:{length:s,type:"unknown"}},Or=e=>(t,n)=>{const r=e(t,n);if(r===null)return r;const s=n+Math.floor((r-1)/8);if(s+r>t.byteLength)return null;let a=t.getUint8(s)&(1<<8-r%8)-1;for(let c=1;c<r;c+=1)a=(a<<8)+t.getUint8(s+c);return{length:r,value:a}},Dt=Symbol.observable||"@@observable";function kr(e){return Symbol.observable||(typeof e=="function"&&e.prototype&&e.prototype[Symbol.observable]?(e.prototype[Dt]=e.prototype[Symbol.observable],delete e.prototype[Symbol.observable]):(e[Dt]=e[Symbol.observable],delete e[Symbol.observable])),e}const Oe=()=>{},Wt=e=>{throw e};function Ir(e){return e?e.next&&e.error&&e.complete?e:{complete:(e.complete??Oe).bind(e),error:(e.error??Wt).bind(e),next:(e.next??Oe).bind(e)}:{complete:Oe,error:Wt,next:Oe}}const Sr=e=>(t,n,r)=>e(s=>{const o=a=>s.next(a);return t.addEventListener(n,o,r),()=>t.removeEventListener(n,o,r)}),Lr=(e,t)=>{const n=()=>{},r=s=>typeof s[0]=="function";return s=>{const o=(...a)=>{const c=s(r(a)?t({next:a[0]}):t(...a));return c!==void 0?c:n};return o[Symbol.observable]=()=>({subscribe:(...a)=>({unsubscribe:o(...a)})}),e(o)}},Ur=Lr(kr,Ir),cn=Sr(Ur),Pr=(e,t,n)=>async r=>{const s=new e([n],{type:"application/javascript; charset=utf-8"}),o=t.createObjectURL(s);try{await r(o)}finally{t.revokeObjectURL(o)}},Br=e=>({data:t})=>{const{id:n}=t;if(n!==null){const r=e.get(n);if(r!==void 0){const{reject:s,resolve:o}=r;e.delete(n),t.error===void 0?o(t.result):s(new Error(t.error.message))}}},Dr=e=>(t,n)=>(r,s=[])=>new Promise((o,a)=>{const c=e(t);t.set(c,{reject:a,resolve:o}),n.postMessage({id:c,...r},s)}),Wr=(e,t,n,r)=>(s,o,a={})=>{const c=new s(o,"recorder-audio-worklet-processor",{...a,channelCountMode:"explicit",numberOfInputs:1,numberOfOutputs:0}),i=new Map,u=t(i,c.port),d=n(c.port,"message")(e(i));c.port.start();let l="inactive";return Object.defineProperties(c,{pause:{get(){return async()=>(r(["recording"],l),l="paused",u({method:"pause"}))}},port:{get(){throw new Error("The port of a RecorderAudioWorkletNode can't be accessed.")}},record:{get(){return async m=>(r(["inactive"],l),l="recording",u({method:"record",params:{encoderPort:m}},[m]))}},resume:{get(){return async()=>(r(["paused"],l),l="recording",u({method:"resume"}))}},stop:{get(){return async()=>{r(["paused","recording"],l),l="stopped";try{await u({method:"stop"})}finally{d()}}}}}),c},xr=(e,t)=>{if(!e.includes(t))throw new Error(`Expected the state to be ${e.map(n=>`"${n}"`).join(" or ")} but it was "${t}".`)},Vr='(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._numberOfChannels=0,this._state="inactive",this.port.onmessage=e=>{let{data:t}=e;"pause"===t.method?"active"===this._state||"recording"===this._state?(this._state="paused",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"record"===t.method?"inactive"===this._state?(this._encoderPort=t.params.encoderPort,this._state="active",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"resume"===t.method?"paused"===this._state?(this._state="active",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"stop"===t.method?"active"!==this._state&&"paused"!==this._state&&"recording"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(t.id):(this._stop(this._encoderPort),this._sendAcknowledgement(t.id)):"number"==typeof t.id&&this.port.postMessage({error:{code:-32601,message:"The requested method is not supported."},id:t.id})}}process(e){let[t]=e;if("inactive"===this._state||"paused"===this._state)return!0;if("active"===this._state){if(void 0===t)throw new Error("No channelData was received for the first input.");if(0===t.length)return!0;this._state="recording"}if("recording"===this._state&&null!==this._encoderPort){if(void 0===t)throw new Error("No channelData was received for the first input.");return 0===t.length?this._encoderPort.postMessage(Array.from({length:this._numberOfChannels},(()=>128))):(this._encoderPort.postMessage(t,t.map((e=>{let{buffer:t}=e;return t}))),this._numberOfChannels=t.length),!0}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:"The internal state does not allow to process the given message."},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state="stopped"}}e.parameterDescriptors=[],registerProcessor("recorder-audio-worklet-processor",e)})();',Fr=Pr(Blob,URL,Vr),jr=Wr(Br,Dr(ft),cn,xr),xt=(e,t,n)=>({endTime:t,insertTime:n,type:"exponentialRampToValue",value:e}),Vt=(e,t,n)=>({endTime:t,insertTime:n,type:"linearRampToValue",value:e}),nt=(e,t)=>({startTime:t,type:"setValue",value:e}),un=(e,t,n)=>({duration:n,startTime:t,type:"setValueCurve",values:e}),ln=(e,t,{startTime:n,target:r,timeConstant:s})=>r+(t-r)*Math.exp((n-e)/s),me=e=>e.type==="exponentialRampToValue",Ue=e=>e.type==="linearRampToValue",re=e=>me(e)||Ue(e),pt=e=>e.type==="setValue",J=e=>e.type==="setValueCurve",Pe=(e,t,n,r)=>{const s=e[t];return s===void 0?r:re(s)||pt(s)?s.value:J(s)?s.values[s.values.length-1]:ln(n,Pe(e,t-1,s.startTime,r),s)},Ft=(e,t,n,r,s)=>n===void 0?[r.insertTime,s]:re(n)?[n.endTime,n.value]:pt(n)?[n.startTime,n.value]:J(n)?[n.startTime+n.duration,n.values[n.values.length-1]]:[n.startTime,Pe(e,t-1,n.startTime,s)],rt=e=>e.type==="cancelAndHold",st=e=>e.type==="cancelScheduledValues",ne=e=>rt(e)||st(e)?e.cancelTime:me(e)||Ue(e)?e.endTime:e.startTime,jt=(e,t,n,{endTime:r,value:s})=>n===s?s:0<n&&0<s||n<0&&s<0?n*(s/n)**((e-t)/(r-t)):0,Gt=(e,t,n,{endTime:r,value:s})=>n+(e-t)/(r-t)*(s-n),Gr=(e,t)=>{const n=Math.floor(t),r=Math.ceil(t);return n===r?e[n]:(1-(t-n))*e[n]+(1-(r-t))*e[r]},qr=(e,{duration:t,startTime:n,values:r})=>{const s=(e-n)/t*(r.length-1);return Gr(r,s)},ke=e=>e.type==="setTarget";class $r{constructor(t){this._automationEvents=[],this._currenTime=0,this._defaultValue=t}[Symbol.iterator](){return this._automationEvents[Symbol.iterator]()}add(t){const n=ne(t);if(rt(t)||st(t)){const r=this._automationEvents.findIndex(o=>st(t)&&J(o)?o.startTime+o.duration>=n:ne(o)>=n),s=this._automationEvents[r];if(r!==-1&&(this._automationEvents=this._automationEvents.slice(0,r)),rt(t)){const o=this._automationEvents[this._automationEvents.length-1];if(s!==void 0&&re(s)){if(o!==void 0&&ke(o))throw new Error("The internal list is malformed.");const a=o===void 0?s.insertTime:J(o)?o.startTime+o.duration:ne(o),c=o===void 0?this._defaultValue:J(o)?o.values[o.values.length-1]:o.value,i=me(s)?jt(n,a,c,s):Gt(n,a,c,s),u=me(s)?xt(i,n,this._currenTime):Vt(i,n,this._currenTime);this._automationEvents.push(u)}if(o!==void 0&&ke(o)&&this._automationEvents.push(nt(this.getValue(n),n)),o!==void 0&&J(o)&&o.startTime+o.duration>n){const a=n-o.startTime,c=(o.values.length-1)/o.duration,i=Math.max(2,1+Math.ceil(a*c)),u=a/(i-1)*c,d=o.values.slice(0,i);if(u<1)for(let l=1;l<i;l+=1){const m=u*l%1;d[l]=o.values[l-1]*(1-m)+o.values[l]*m}this._automationEvents[this._automationEvents.length-1]=un(d,o.startTime,a)}}}else{const r=this._automationEvents.findIndex(a=>ne(a)>n),s=r===-1?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[r-1];if(s!==void 0&&J(s)&&ne(s)+s.duration>n)return!1;const o=me(t)?xt(t.value,t.endTime,this._currenTime):Ue(t)?Vt(t.value,n,this._currenTime):t;if(r===-1)this._automationEvents.push(o);else{if(J(t)&&n+t.duration>ne(this._automationEvents[r]))return!1;this._automationEvents.splice(r,0,o)}}return!0}flush(t){const n=this._automationEvents.findIndex(r=>ne(r)>t);if(n>1){const r=this._automationEvents.slice(n-1),s=r[0];ke(s)&&r.unshift(nt(Pe(this._automationEvents,n-2,s.startTime,this._defaultValue),s.startTime)),this._automationEvents=r}}getValue(t){if(this._automationEvents.length===0)return this._defaultValue;const n=this._automationEvents.findIndex(a=>ne(a)>t),r=this._automationEvents[n],s=(n===-1?this._automationEvents.length:n)-1,o=this._automationEvents[s];if(o!==void 0&&ke(o)&&(r===void 0||!re(r)||r.insertTime>t))return ln(t,Pe(this._automationEvents,s-1,o.startTime,this._defaultValue),o);if(o!==void 0&&pt(o)&&(r===void 0||!re(r)))return o.value;if(o!==void 0&&J(o)&&(r===void 0||!re(r)||o.startTime+o.duration>t))return t<o.startTime+o.duration?qr(t,o):o.values[o.values.length-1];if(o!==void 0&&re(o)&&(r===void 0||!re(r)))return o.value;if(r!==void 0&&me(r)){const[a,c]=Ft(this._automationEvents,s,o,r,this._defaultValue);return jt(t,a,c,r)}if(r!==void 0&&Ue(r)){const[a,c]=Ft(this._automationEvents,s,o,r,this._defaultValue);return Gt(t,a,c,r)}return this._defaultValue}}const zr=e=>({cancelTime:e,type:"cancelAndHold"}),Xr=e=>({cancelTime:e,type:"cancelScheduledValues"}),Hr=(e,t)=>({endTime:t,type:"exponentialRampToValue",value:e}),Yr=(e,t)=>({endTime:t,type:"linearRampToValue",value:e}),Zr=(e,t,n)=>({startTime:t,target:e,timeConstant:n,type:"setTarget"}),Qr=()=>new DOMException("","AbortError"),Kr=e=>(t,n,[r,s,o],a)=>{e(t[s],[n,r,o],c=>c[0]===n&&c[1]===r,a)},Jr=e=>(t,n,r)=>{const s=[];for(let o=0;o<r.numberOfInputs;o+=1)s.push(new Set);e.set(t,{activeInputs:s,outputs:new Set,passiveInputs:new WeakMap,renderer:n})},es=e=>(t,n)=>{e.set(t,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:n})},ge=new WeakSet,dn=new WeakMap,fn=new WeakMap,hn=new WeakMap,pn=new WeakMap,mn=new WeakMap,gn=new WeakMap,ot=new WeakMap,at=new WeakMap,it=new WeakMap,wn={construct(){return wn}},ts=e=>{try{const t=new Proxy(e,wn);new t}catch{return!1}return!0},qt=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,$t=(e,t)=>{const n=[];let r=e.replace(/^[\s]+/,""),s=r.match(qt);for(;s!==null;){const o=s[1].slice(1,-1),a=s[0].replace(/([\s]+)?;?$/,"").replace(o,new URL(o,t).toString());n.push(a),r=r.slice(s[0].length).replace(/^[\s]+/,""),s=r.match(qt)}return[n.join(";"),r]},zt=e=>{if(e!==void 0&&!Array.isArray(e))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},Xt=e=>{if(!ts(e))throw new TypeError("The given value for processorCtor should be a constructor.");if(e.prototype===null||typeof e.prototype!="object")throw new TypeError("The given value for processorCtor should have a prototype.")},ns=(e,t,n,r,s,o,a,c,i,u,d,l,m)=>{let w=0;return(p,f,g={credentials:"omit"})=>{const h=d.get(p);if(h!==void 0&&h.has(f))return Promise.resolve();const A=u.get(p);if(A!==void 0){const E=A.get(f);if(E!==void 0)return E}const v=o(p),T=v.audioWorklet===void 0?s(f).then(([E,b])=>{const[y,_]=$t(E,b),M=`${y};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${_}
})})(window,'_AWGS')`;return n(M)}).then(()=>{const E=m._AWGS.pop();if(E===void 0)throw new SyntaxError;r(v.currentTime,v.sampleRate,()=>E(class{},void 0,(b,y)=>{if(b.trim()==="")throw t();const _=at.get(v);if(_!==void 0){if(_.has(b))throw t();Xt(y),zt(y.parameterDescriptors),_.set(b,y)}else Xt(y),zt(y.parameterDescriptors),at.set(v,new Map([[b,y]]))},v.sampleRate,void 0,void 0))}):Promise.all([s(f),Promise.resolve(e(l,l))]).then(([[E,b],y])=>{const _=w+1;w=_;const[M,I]=$t(E,b),P=`${M};((AudioWorkletProcessor,registerProcessor)=>{${I}
})(${y?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${y?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${y?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${_}',class extends AudioWorkletProcessor{process(){return !1}})`,D=new Blob([P],{type:"application/javascript; charset=utf-8"}),k=URL.createObjectURL(D);return v.audioWorklet.addModule(k,g).then(()=>{if(c(v))return v;const B=a(v);return B.audioWorklet.addModule(k,g).then(()=>B)}).then(B=>{if(i===null)throw new SyntaxError;try{new i(B,`__sac${_}`)}catch{throw new SyntaxError}}).finally(()=>URL.revokeObjectURL(k))});return A===void 0?u.set(p,new Map([[f,T]])):A.set(f,T),T.then(()=>{const E=d.get(p);E===void 0?d.set(p,new Set([f])):E.add(f)}).finally(()=>{const E=u.get(p);E!==void 0&&E.delete(f)}),T}},Q=(e,t)=>{const n=e.get(t);if(n===void 0)throw new Error("A value with the given key could not be found.");return n},Fe=(e,t)=>{const n=Array.from(e).filter(t);if(n.length>1)throw Error("More than one element was found.");if(n.length===0)throw Error("No element was found.");const[r]=n;return e.delete(r),r},vn=(e,t,n,r)=>{const s=Q(e,t),o=Fe(s,a=>a[0]===n&&a[1]===r);return s.size===0&&e.delete(t),o},Ce=e=>Q(gn,e),Be=e=>{if(ge.has(e))throw new Error("The AudioNode is already stored.");ge.add(e),Ce(e).forEach(t=>t(!0))},_n=e=>"port"in e,mt=e=>{if(!ge.has(e))throw new Error("The AudioNode is not stored.");ge.delete(e),Ce(e).forEach(t=>t(!1))},ct=(e,t)=>{!_n(e)&&t.every(n=>n.size===0)&&mt(e)},rs=(e,t,n,r,s,o,a,c,i,u,d,l,m)=>{const w=new WeakMap;return(p,f,g,h,A)=>{const{activeInputs:v,passiveInputs:T}=o(f),{outputs:E}=o(p),b=c(p),y=_=>{const M=i(f),I=i(p);if(_){const N=vn(T,p,g,h);e(v,p,N,!1),!A&&!l(p)&&n(I,M,g,h),m(f)&&Be(f)}else{const N=r(v,p,g,h);t(T,h,N,!1),!A&&!l(p)&&s(I,M,g,h);const L=a(f);if(L===0)d(f)&&ct(f,v);else{const U=w.get(f);U!==void 0&&clearTimeout(U),w.set(f,setTimeout(()=>{d(f)&&ct(f,v)},L*1e3))}}};return u(E,[f,g,h],_=>_[0]===f&&_[1]===g&&_[2]===h,!0)?(b.add(y),d(p)?e(v,p,[g,h,y],!0):t(T,h,[p,g,y],!0),!0):!1}},ss=e=>(t,n,[r,s,o],a)=>{const c=t.get(r);c===void 0?t.set(r,new Set([[s,n,o]])):e(c,[s,n,o],i=>i[0]===s&&i[1]===n,a)},os=e=>(t,n)=>{const r=e(t,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});n.connect(r).connect(t.destination);const s=()=>{n.removeEventListener("ended",s),n.disconnect(r),r.disconnect()};n.addEventListener("ended",s)},as=e=>(t,n)=>{e(t).add(n)},yn=(e,t)=>e.context===t,Ht=e=>{try{e.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},ue=()=>new DOMException("","IndexSizeError"),is=e=>{e.getChannelData=(t=>n=>{try{return t.call(e,n)}catch(r){throw r.code===12?ue():r}})(e.getChannelData)},cs={numberOfChannels:1},us=(e,t,n,r,s,o,a,c)=>{let i=null;return class En{constructor(d){if(s===null)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:l,numberOfChannels:m,sampleRate:w}={...cs,...d};i===null&&(i=new s(1,1,44100));const p=r!==null&&t(o,o)?new r({length:l,numberOfChannels:m,sampleRate:w}):i.createBuffer(m,l,w);if(p.numberOfChannels===0)throw n();return typeof p.copyFromChannel!="function"?(a(p),is(p)):t(Ht,()=>Ht(p))||c(p),e.add(p),p}static[Symbol.hasInstance](d){return d!==null&&typeof d=="object"&&Object.getPrototypeOf(d)===En.prototype||e.has(d)}}},je=-34028234663852886e22,gt=-je,ae=e=>ge.has(e),ls={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},ds=(e,t,n,r,s,o,a,c)=>class extends e{constructor(u,d){const l=o(u),m={...ls,...d},w=s(l,m),p=a(l),f=p?t():null;super(u,!1,w,f),this._audioBufferSourceNodeRenderer=f,this._isBufferNullified=!1,this._isBufferSet=m.buffer!==null,this._nativeAudioBufferSourceNode=w,this._onended=null,this._playbackRate=n(this,p,w.playbackRate,gt,je)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(u){if(this._nativeAudioBufferSourceNode.buffer=u,u!==null){if(this._isBufferSet)throw r();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(u){this._nativeAudioBufferSourceNode.loop=u}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(u){this._nativeAudioBufferSourceNode.loopEnd=u}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(u){this._nativeAudioBufferSourceNode.loopStart=u}get onended(){return this._onended}set onended(u){const d=typeof u=="function"?c(this,u):null;this._nativeAudioBufferSourceNode.onended=d;const l=this._nativeAudioBufferSourceNode.onended;this._onended=l!==null&&l===d?u:l}get playbackRate(){return this._playbackRate}start(u=0,d=0,l){if(this._nativeAudioBufferSourceNode.start(u,d,l),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.start=l===void 0?[u,d]:[u,d,l]),this.context.state!=="closed"){Be(this);const m=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",m),ae(this)&&mt(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",m)}}stop(u=0){this._nativeAudioBufferSourceNode.stop(u),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.stop=u)}},fs=(e,t,n,r,s)=>()=>{const o=new WeakMap;let a=null,c=null;const i=async(u,d)=>{let l=n(u);const m=yn(l,d);if(!m){const w={buffer:l.buffer,channelCount:l.channelCount,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,loop:l.loop,loopEnd:l.loopEnd,loopStart:l.loopStart,playbackRate:l.playbackRate.value};l=t(d,w),a!==null&&l.start(...a),c!==null&&l.stop(c)}return o.set(d,l),m?await e(d,u.playbackRate,l.playbackRate):await r(d,u.playbackRate,l.playbackRate),await s(u,d,l),l};return{set start(u){a=u},set stop(u){c=u},render(u,d){const l=o.get(d);return l!==void 0?Promise.resolve(l):i(u,d)}}},hs=e=>"playbackRate"in e,ps=e=>"frequency"in e&&"gain"in e,ms=e=>"offset"in e,gs=e=>!("frequency"in e)&&"gain"in e,ws=e=>"detune"in e&&"frequency"in e&&!("gain"in e),vs=e=>"pan"in e,z=e=>Q(dn,e),Te=e=>Q(hn,e),ut=(e,t)=>{const{activeInputs:n}=z(e);n.forEach(s=>s.forEach(([o])=>{t.includes(e)||ut(o,[...t,e])}));const r=hs(e)?[e.playbackRate]:_n(e)?Array.from(e.parameters.values()):ps(e)?[e.Q,e.detune,e.frequency,e.gain]:ms(e)?[e.offset]:gs(e)?[e.gain]:ws(e)?[e.detune,e.frequency]:vs(e)?[e.pan]:[];for(const s of r){const o=Te(s);o!==void 0&&o.activeInputs.forEach(([a])=>ut(a,t))}ae(e)&&mt(e)},_s=e=>{ut(e.destination,[])},ys=e=>e===void 0||typeof e=="number"||typeof e=="string"&&(e==="balanced"||e==="interactive"||e==="playback"),Es=(e,t,n,r,s,o,a,c)=>class extends e{constructor(u,d){const l=o(u),m=a(l),w=s(l,d,m),p=m?t(c):null;super(u,!1,w,p),this._isNodeOfNativeOfflineAudioContext=m,this._nativeAudioDestinationNode=w}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(u){if(this._isNodeOfNativeOfflineAudioContext)throw r();if(u>this._nativeAudioDestinationNode.maxChannelCount)throw n();this._nativeAudioDestinationNode.channelCount=u}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(u){if(this._isNodeOfNativeOfflineAudioContext)throw r();this._nativeAudioDestinationNode.channelCountMode=u}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}},bs=e=>{const t=new WeakMap,n=async(r,s)=>{const o=s.destination;return t.set(s,o),await e(r,s,o),o};return{render(r,s){const o=t.get(s);return o!==void 0?Promise.resolve(o):n(r,s)}}},As=(e,t,n,r,s,o,a,c)=>(i,u)=>{const d=u.listener,l=()=>{const E=new Float32Array(1),b=t(u,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),y=a(u);let _=!1,M=[0,0,-1,0,1,0],I=[0,0,0];const N=()=>{if(_)return;_=!0;const D=r(u,256,9,0);D.onaudioprocess=({inputBuffer:k})=>{const B=[o(k,E,0),o(k,E,1),o(k,E,2),o(k,E,3),o(k,E,4),o(k,E,5)];B.some((R,S)=>R!==M[S])&&(d.setOrientation(...B),M=B);const x=[o(k,E,6),o(k,E,7),o(k,E,8)];x.some((R,S)=>R!==I[S])&&(d.setPosition(...x),I=x)},b.connect(D)},L=D=>k=>{k!==M[D]&&(M[D]=k,d.setOrientation(...M))},U=D=>k=>{k!==I[D]&&(I[D]=k,d.setPosition(...I))},P=(D,k,B)=>{const x=n(u,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:k});x.connect(b,0,D),x.start(),Object.defineProperty(x.offset,"defaultValue",{get(){return k}});const R=e({context:i},y,x.offset,gt,je);return c(R,"value",S=>()=>S.call(R),S=>V=>{try{S.call(R,V)}catch(q){if(q.code!==9)throw q}N(),y&&B(V)}),R.cancelAndHoldAtTime=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.cancelAndHoldAtTime),R.cancelScheduledValues=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.cancelScheduledValues),R.exponentialRampToValueAtTime=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.exponentialRampToValueAtTime),R.linearRampToValueAtTime=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.linearRampToValueAtTime),R.setTargetAtTime=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.setTargetAtTime),R.setValueAtTime=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.setValueAtTime),R.setValueCurveAtTime=(S=>y?()=>{throw s()}:(...V)=>{const q=S.apply(R,V);return N(),q})(R.setValueCurveAtTime),R};return{forwardX:P(0,0,L(0)),forwardY:P(1,0,L(1)),forwardZ:P(2,-1,L(2)),positionX:P(6,0,U(0)),positionY:P(7,0,U(1)),positionZ:P(8,0,U(2)),upX:P(3,0,L(3)),upY:P(4,1,L(4)),upZ:P(5,0,L(5))}},{forwardX:m,forwardY:w,forwardZ:p,positionX:f,positionY:g,positionZ:h,upX:A,upY:v,upZ:T}=d.forwardX===void 0?l():d;return{get forwardX(){return m},get forwardY(){return w},get forwardZ(){return p},get positionX(){return f},get positionY(){return g},get positionZ(){return h},get upX(){return A},get upY(){return v},get upZ(){return T}}},De=e=>"context"in e,Me=e=>De(e[0]),le=(e,t,n,r)=>{for(const s of e)if(n(s)){if(r)return!1;throw Error("The set contains at least one similar element.")}return e.add(t),!0},Yt=(e,t,[n,r],s)=>{le(e,[t,n,r],o=>o[0]===t&&o[1]===n,s)},Zt=(e,[t,n,r],s)=>{const o=e.get(t);o===void 0?e.set(t,new Set([[n,r]])):le(o,[n,r],a=>a[0]===n,s)},bn=e=>"inputs"in e,lt=(e,t,n,r)=>{if(bn(t)){const s=t.inputs[r];return e.connect(s,n,0),[s,n,0]}return e.connect(t,n,r),[t,n,r]},An=(e,t,n)=>{for(const r of e)if(r[0]===t&&r[1]===n)return e.delete(r),r;return null},Cs=(e,t,n)=>Fe(e,r=>r[0]===t&&r[1]===n),Cn=(e,t)=>{if(!Ce(e).delete(t))throw new Error("Missing the expected event listener.")},Tn=(e,t,n)=>{const r=Q(e,t),s=Fe(r,o=>o[0]===n);return r.size===0&&e.delete(t),s},dt=(e,t,n,r)=>{bn(t)?e.disconnect(t.inputs[r],n,0):e.disconnect(t,n,r)},Y=e=>Q(fn,e),be=e=>Q(pn,e),ie=e=>ot.has(e),Se=e=>!ge.has(e),Qt=(e,t)=>new Promise(n=>{if(t!==null)n(!0);else{const r=e.createScriptProcessor(256,1,1),s=e.createGain(),o=e.createBuffer(1,2,44100),a=o.getChannelData(0);a[0]=1,a[1]=1;const c=e.createBufferSource();c.buffer=o,c.loop=!0,c.connect(r).connect(e.destination),c.connect(s),c.disconnect(s),r.onaudioprocess=i=>{const u=i.inputBuffer.getChannelData(0);Array.prototype.some.call(u,d=>d===1)?n(!0):n(!1),c.stop(),r.onaudioprocess=null,c.disconnect(r),r.disconnect(e.destination)},c.start()}}),Je=(e,t)=>{const n=new Map;for(const r of e)for(const s of r){const o=n.get(s);n.set(s,o===void 0?1:o+1)}n.forEach((r,s)=>t(s,r))},We=e=>"context"in e,Ts=e=>{const t=new Map;e.connect=(n=>(r,s=0,o=0)=>{const a=We(r)?n(r,s,o):n(r,s),c=t.get(r);return c===void 0?t.set(r,[{input:o,output:s}]):c.every(i=>i.input!==o||i.output!==s)&&c.push({input:o,output:s}),a})(e.connect.bind(e)),e.disconnect=(n=>(r,s,o)=>{if(n.apply(e),r===void 0)t.clear();else if(typeof r=="number")for(const[a,c]of t){const i=c.filter(u=>u.output!==r);i.length===0?t.delete(a):t.set(a,i)}else if(t.has(r))if(s===void 0)t.delete(r);else{const a=t.get(r);if(a!==void 0){const c=a.filter(i=>i.output!==s&&(i.input!==o||o===void 0));c.length===0?t.delete(r):t.set(r,c)}}for(const[a,c]of t)c.forEach(i=>{We(a)?e.connect(a,i.output,i.input):e.connect(a,i.output)})})(e.disconnect)},Ms=(e,t,n,r)=>{const{activeInputs:s,passiveInputs:o}=Te(t),{outputs:a}=z(e),c=Ce(e),i=u=>{const d=Y(e),l=be(t);if(u){const m=Tn(o,e,n);Yt(s,e,m,!1),!r&&!ie(e)&&d.connect(l,n)}else{const m=Cs(s,e,n);Zt(o,m,!1),!r&&!ie(e)&&d.disconnect(l,n)}};return le(a,[t,n],u=>u[0]===t&&u[1]===n,!0)?(c.add(i),ae(e)?Yt(s,e,[n,i],!0):Zt(o,[e,n,i],!0),!0):!1},Ns=(e,t,n,r)=>{const{activeInputs:s,passiveInputs:o}=z(t),a=An(s[r],e,n);return a===null?[vn(o,e,n,r)[2],!1]:[a[2],!0]},Rs=(e,t,n)=>{const{activeInputs:r,passiveInputs:s}=Te(t),o=An(r,e,n);return o===null?[Tn(s,e,n)[1],!1]:[o[2],!0]},wt=(e,t,n,r,s)=>{const[o,a]=Ns(e,n,r,s);if(o!==null&&(Cn(e,o),a&&!t&&!ie(e)&&dt(Y(e),Y(n),r,s)),ae(n)){const{activeInputs:c}=z(n);ct(n,c)}},vt=(e,t,n,r)=>{const[s,o]=Rs(e,n,r);s!==null&&(Cn(e,s),o&&!t&&!ie(e)&&Y(e).disconnect(be(n),r))},Os=(e,t)=>{const n=z(e),r=[];for(const s of n.outputs)Me(s)?wt(e,t,...s):vt(e,t,...s),r.push(s[0]);return n.outputs.clear(),r},ks=(e,t,n)=>{const r=z(e),s=[];for(const o of r.outputs)o[1]===n&&(Me(o)?wt(e,t,...o):vt(e,t,...o),s.push(o[0]),r.outputs.delete(o));return s},Is=(e,t,n,r,s)=>{const o=z(e);return Array.from(o.outputs).filter(a=>a[0]===n&&(r===void 0||a[1]===r)&&(s===void 0||a[2]===s)).map(a=>(Me(a)?wt(e,t,...a):vt(e,t,...a),o.outputs.delete(a),a[0]))},Ss=(e,t,n,r,s,o,a,c,i,u,d,l,m,w,p,f)=>class extends u{constructor(h,A,v,T){super(v),this._context=h,this._nativeAudioNode=v;const E=d(h);l(E)&&n(Qt,()=>Qt(E,f))!==!0&&Ts(v),fn.set(this,v),gn.set(this,new Set),h.state!=="closed"&&A&&Be(this),e(this,T,v)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(h){this._nativeAudioNode.channelCount=h}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(h){this._nativeAudioNode.channelCountMode=h}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(h){this._nativeAudioNode.channelInterpretation=h}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(h,A=0,v=0){if(A<0||A>=this._nativeAudioNode.numberOfOutputs)throw s();const T=d(this._context),E=p(T);if(m(h)||w(h))throw o();if(De(h)){const _=Y(h);try{const I=lt(this._nativeAudioNode,_,A,v),N=Se(this);(E||N)&&this._nativeAudioNode.disconnect(...I),this.context.state!=="closed"&&!N&&Se(h)&&Be(h)}catch(I){throw I.code===12?o():I}if(t(this,h,A,v,E)){const I=i([this],h);Je(I,r(E))}return h}const b=be(h);if(b.name==="playbackRate"&&b.maxValue===1024)throw a();try{this._nativeAudioNode.connect(b,A),(E||Se(this))&&this._nativeAudioNode.disconnect(b,A)}catch(_){throw _.code===12?o():_}if(Ms(this,h,A,E)){const _=i([this],h);Je(_,r(E))}}disconnect(h,A,v){let T;const E=d(this._context),b=p(E);if(h===void 0)T=Os(this,b);else if(typeof h=="number"){if(h<0||h>=this.numberOfOutputs)throw s();T=ks(this,b,h)}else{if(A!==void 0&&(A<0||A>=this.numberOfOutputs)||De(h)&&v!==void 0&&(v<0||v>=h.numberOfInputs))throw s();if(T=Is(this,b,h,A,v),T.length===0)throw o()}for(const y of T){const _=i([this],y);Je(_,c)}}},Ls=(e,t,n,r,s,o,a,c,i,u,d,l,m)=>(w,p,f,g=null,h=null)=>{const A=f.value,v=new $r(A),T=p?r(v):null,E={get defaultValue(){return A},get maxValue(){return g===null?f.maxValue:g},get minValue(){return h===null?f.minValue:h},get value(){return f.value},set value(b){f.value=b,E.setValueAtTime(b,w.context.currentTime)},cancelAndHoldAtTime(b){if(typeof f.cancelAndHoldAtTime=="function")T===null&&v.flush(w.context.currentTime),v.add(s(b)),f.cancelAndHoldAtTime(b);else{const y=Array.from(v).pop();T===null&&v.flush(w.context.currentTime),v.add(s(b));const _=Array.from(v).pop();f.cancelScheduledValues(b),y!==_&&_!==void 0&&(_.type==="exponentialRampToValue"?f.exponentialRampToValueAtTime(_.value,_.endTime):_.type==="linearRampToValue"?f.linearRampToValueAtTime(_.value,_.endTime):_.type==="setValue"?f.setValueAtTime(_.value,_.startTime):_.type==="setValueCurve"&&f.setValueCurveAtTime(_.values,_.startTime,_.duration))}return E},cancelScheduledValues(b){return T===null&&v.flush(w.context.currentTime),v.add(o(b)),f.cancelScheduledValues(b),E},exponentialRampToValueAtTime(b,y){if(b===0)throw new RangeError;if(!Number.isFinite(y)||y<0)throw new RangeError;const _=w.context.currentTime;return T===null&&v.flush(_),Array.from(v).length===0&&(v.add(u(A,_)),f.setValueAtTime(A,_)),v.add(a(b,y)),f.exponentialRampToValueAtTime(b,y),E},linearRampToValueAtTime(b,y){const _=w.context.currentTime;return T===null&&v.flush(_),Array.from(v).length===0&&(v.add(u(A,_)),f.setValueAtTime(A,_)),v.add(c(b,y)),f.linearRampToValueAtTime(b,y),E},setTargetAtTime(b,y,_){return T===null&&v.flush(w.context.currentTime),v.add(i(b,y,_)),f.setTargetAtTime(b,y,_),E},setValueAtTime(b,y){return T===null&&v.flush(w.context.currentTime),v.add(u(b,y)),f.setValueAtTime(b,y),E},setValueCurveAtTime(b,y,_){const M=b instanceof Float32Array?b:new Float32Array(b);if(l!==null&&l.name==="webkitAudioContext"){const I=y+_,N=w.context.sampleRate,L=Math.ceil(y*N),U=Math.floor(I*N),P=U-L,D=new Float32Array(P);for(let B=0;B<P;B+=1){const x=(M.length-1)/_*((L+B)/N-y),R=Math.floor(x),S=Math.ceil(x);D[B]=R===S?M[R]:(1-(x-R))*M[R]+(1-(S-x))*M[S]}T===null&&v.flush(w.context.currentTime),v.add(d(D,y,_)),f.setValueCurveAtTime(D,y,_);const k=U/N;k<I&&m(E,D[D.length-1],k),m(E,M[M.length-1],I)}else T===null&&v.flush(w.context.currentTime),v.add(d(M,y,_)),f.setValueCurveAtTime(M,y,_);return E}};return n.set(E,f),t.set(E,w),e(E,T),E},Us=e=>({replay(t){for(const n of e)if(n.type==="exponentialRampToValue"){const{endTime:r,value:s}=n;t.exponentialRampToValueAtTime(s,r)}else if(n.type==="linearRampToValue"){const{endTime:r,value:s}=n;t.linearRampToValueAtTime(s,r)}else if(n.type==="setTarget"){const{startTime:r,target:s,timeConstant:o}=n;t.setTargetAtTime(s,r,o)}else if(n.type==="setValue"){const{startTime:r,value:s}=n;t.setValueAtTime(s,r)}else if(n.type==="setValueCurve"){const{duration:r,startTime:s,values:o}=n;t.setValueCurveAtTime(o,s,r)}else throw new Error("Can't apply an unknown automation.")}});class Mn{constructor(t){this._map=new Map(t)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(t,n=null){return this._map.forEach((r,s)=>t.call(n,r,s,this))}get(t){return this._map.get(t)}has(t){return this._map.has(t)}keys(){return this._map.keys()}values(){return this._map.values()}}const Ps={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}},Bs=(e,t,n,r,s,o,a,c,i,u,d,l,m,w)=>class extends t{constructor(f,g,h){var A;const v=c(f),T=i(v),E=d({...Ps,...h});m(E);const b=at.get(v),y=b==null?void 0:b.get(g),_=T||v.state!=="closed"?v:(A=a(v))!==null&&A!==void 0?A:v,M=s(_,T?null:f.baseLatency,u,g,y,E),I=T?r(g,E,y):null;super(f,!0,M,I);const N=[];M.parameters.forEach((U,P)=>{const D=n(this,T,U);N.push([P,D])}),this._nativeAudioWorkletNode=M,this._onprocessorerror=null,this._parameters=new Mn(N),T&&e(v,this);const{activeInputs:L}=o(this);l(M,L)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(f){const g=typeof f=="function"?w(this,f):null;this._nativeAudioWorkletNode.onprocessorerror=g;const h=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=h!==null&&h===g?f:h}get parameters(){return this._parameters===null?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}};function xe(e,t,n,r,s){if(typeof e.copyFromChannel=="function")t[n].byteLength===0&&(t[n]=new Float32Array(128)),e.copyFromChannel(t[n],r,s);else{const o=e.getChannelData(r);if(t[n].byteLength===0)t[n]=o.slice(s,s+128);else{const a=new Float32Array(o.buffer,s*Float32Array.BYTES_PER_ELEMENT,128);t[n].set(a)}}}const Nn=(e,t,n,r,s)=>{typeof e.copyToChannel=="function"?t[n].byteLength!==0&&e.copyToChannel(t[n],r,s):t[n].byteLength!==0&&e.getChannelData(r).set(t[n],s)},Ve=(e,t)=>{const n=[];for(let r=0;r<e;r+=1){const s=[],o=typeof t=="number"?t:t[r];for(let a=0;a<o;a+=1)s.push(new Float32Array(128));n.push(s)}return n},Ds=(e,t)=>{const n=Q(it,e),r=Y(t);return Q(n,r)},Ws=async(e,t,n,r,s,o,a)=>{const c=t===null?Math.ceil(e.context.length/128)*128:t.length,i=r.channelCount*r.numberOfInputs,u=s.reduce((g,h)=>g+h,0),d=u===0?null:n.createBuffer(u,c,n.sampleRate);if(o===void 0)throw new Error("Missing the processor constructor.");const l=z(e),m=await Ds(n,e),w=Ve(r.numberOfInputs,r.channelCount),p=Ve(r.numberOfOutputs,s),f=Array.from(e.parameters.keys()).reduce((g,h)=>({...g,[h]:new Float32Array(128)}),{});for(let g=0;g<c;g+=128){if(r.numberOfInputs>0&&t!==null)for(let h=0;h<r.numberOfInputs;h+=1)for(let A=0;A<r.channelCount;A+=1)xe(t,w[h],A,A,g);o.parameterDescriptors!==void 0&&t!==null&&o.parameterDescriptors.forEach(({name:h},A)=>{xe(t,f,h,i+A,g)});for(let h=0;h<r.numberOfInputs;h+=1)for(let A=0;A<s[h];A+=1)p[h][A].byteLength===0&&(p[h][A]=new Float32Array(128));try{const h=w.map((v,T)=>l.activeInputs[T].size===0?[]:v),A=a(g/n.sampleRate,n.sampleRate,()=>m.process(h,p,f));if(d!==null)for(let v=0,T=0;v<r.numberOfOutputs;v+=1){for(let E=0;E<s[v];E+=1)Nn(d,p[v],E,T+E,g);T+=s[v]}if(!A)break}catch(h){e.dispatchEvent(new ErrorEvent("processorerror",{colno:h.colno,filename:h.filename,lineno:h.lineno,message:h.message}));break}}return d},xs=(e,t,n,r,s,o,a,c,i,u,d,l,m,w,p,f)=>(g,h,A)=>{const v=new WeakMap;let T=null;const E=async(b,y)=>{let _=d(b),M=null;const I=yn(_,y),N=Array.isArray(h.outputChannelCount)?h.outputChannelCount:Array.from(h.outputChannelCount);if(l===null){const L=N.reduce((k,B)=>k+B,0),U=s(y,{channelCount:Math.max(1,L),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,L)}),P=[];for(let k=0;k<b.numberOfOutputs;k+=1)P.push(r(y,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:N[k]}));const D=a(y,{channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,gain:1});D.connect=t.bind(null,P),D.disconnect=i.bind(null,P),M=[U,P,D]}else I||(_=new l(y,g));if(v.set(y,M===null?_:M[2]),M!==null){if(T===null){if(A===void 0)throw new Error("Missing the processor constructor.");if(m===null)throw new Error("Missing the native OfflineAudioContext constructor.");const B=b.channelCount*b.numberOfInputs,x=A.parameterDescriptors===void 0?0:A.parameterDescriptors.length,R=B+x;T=Ws(b,R===0?null:await(async()=>{const V=new m(R,Math.ceil(b.context.length/128)*128,y.sampleRate),q=[],fe=[];for(let j=0;j<h.numberOfInputs;j+=1)q.push(a(V,{channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,gain:1})),fe.push(s(V,{channelCount:h.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:h.channelCount}));const he=await Promise.all(Array.from(b.parameters.values()).map(async j=>{const X=o(V,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:j.value});return await w(V,j,X.offset),X})),pe=r(V,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,B+x)});for(let j=0;j<h.numberOfInputs;j+=1){q[j].connect(fe[j]);for(let X=0;X<h.channelCount;X+=1)fe[j].connect(pe,X,j*h.channelCount+X)}for(const[j,X]of he.entries())X.connect(pe,0,B+j),X.start(0);return pe.connect(V.destination),await Promise.all(q.map(j=>p(b,V,j))),f(V)})(),y,h,N,A,u)}const L=await T,U=n(y,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[P,D,k]=M;L!==null&&(U.buffer=L,U.start(0)),U.connect(P);for(let B=0,x=0;B<b.numberOfOutputs;B+=1){const R=D[B];for(let S=0;S<N[B];S+=1)P.connect(R,x+S,S);x+=N[B]}return k}if(I)for(const[L,U]of b.parameters.entries())await e(y,U,_.parameters.get(L));else for(const[L,U]of b.parameters.entries())await w(y,U,_.parameters.get(L));return await p(b,y,_),_};return{render(b,y){c(y,b);const _=v.get(y);return _!==void 0?Promise.resolve(_):E(b,y)}}},Vs=(e,t)=>(n,r)=>{const s=t.get(n);if(s!==void 0)return s;const o=e.get(n);if(o!==void 0)return o;try{const a=r();return a instanceof Promise?(e.set(n,a),a.catch(()=>!1).then(c=>(e.delete(n),t.set(n,c),c))):(t.set(n,a),a)}catch{return t.set(n,!1),!1}},Fs=e=>(t,n,r)=>e(n,t,r),js=e=>(t,n,r=0,s=0)=>{const o=t[r];if(o===void 0)throw e();return We(n)?o.connect(n,0,s):o.connect(n,0)},Gs=e=>t=>(e[0]=t,e[0]),qs=(e,t,n,r,s,o,a,c)=>(i,u)=>{const d=t.get(i);if(d===void 0)throw new Error("Missing the expected cycle count.");const l=o(i.context),m=c(l);if(d===u){if(t.delete(i),!m&&a(i)){const w=r(i),{outputs:p}=n(i);for(const f of p)if(Me(f)){const g=r(f[0]);e(w,g,f[1],f[2])}else{const g=s(f[0]);w.connect(g,f[1])}}}else t.set(i,d-u)},$s=e=>(t,n,r,s)=>e(t[s],o=>o[0]===n&&o[1]===r),zs=e=>(t,n)=>{e(t).delete(n)},Xs=e=>"delayTime"in e,Hs=(e,t,n)=>function r(s,o){const a=De(o)?o:n(e,o);if(Xs(a))return[];if(s[0]===a)return[s];if(s.includes(a))return[];const{outputs:c}=t(a);return Array.from(c).map(i=>r([...s,a],i[0])).reduce((i,u)=>i.concat(u),[])},Ie=(e,t,n)=>{const r=t[n];if(r===void 0)throw e();return r},Ys=e=>(t,n=void 0,r=void 0,s=0)=>n===void 0?t.forEach(o=>o.disconnect()):typeof n=="number"?Ie(e,t,n).disconnect():We(n)?r===void 0?t.forEach(o=>o.disconnect(n)):s===void 0?Ie(e,t,r).disconnect(n,0):Ie(e,t,r).disconnect(n,0,s):r===void 0?t.forEach(o=>o.disconnect(n)):Ie(e,t,r).disconnect(n,0),Zs=e=>t=>new Promise((n,r)=>{if(e===null){r(new SyntaxError);return}const s=e.document.head;if(s===null)r(new SyntaxError);else{const o=e.document.createElement("script"),a=new Blob([t],{type:"application/javascript"}),c=URL.createObjectURL(a),i=e.onerror,u=()=>{e.onerror=i,URL.revokeObjectURL(c)};e.onerror=(d,l,m,w,p)=>{if(l===c||l===e.location.href&&m===1&&w===1)return u(),r(p),!1;if(i!==null)return i(d,l,m,w,p)},o.onerror=()=>{u(),r(new SyntaxError)},o.onload=()=>{u(),n()},o.src=c,o.type="module",s.appendChild(o)}}),Qs=e=>class{constructor(n){this._nativeEventTarget=n,this._listeners=new WeakMap}addEventListener(n,r,s){if(r!==null){let o=this._listeners.get(r);o===void 0&&(o=e(this,r),typeof r=="function"&&this._listeners.set(r,o)),this._nativeEventTarget.addEventListener(n,o,s)}}dispatchEvent(n){return this._nativeEventTarget.dispatchEvent(n)}removeEventListener(n,r,s){const o=r===null?void 0:this._listeners.get(r);this._nativeEventTarget.removeEventListener(n,o===void 0?null:o,s)}},Ks=e=>(t,n,r)=>{Object.defineProperties(e,{currentFrame:{configurable:!0,get(){return Math.round(t*n)}},currentTime:{configurable:!0,get(){return t}}});try{return r()}finally{e!==null&&(delete e.currentFrame,delete e.currentTime)}},Js=e=>async t=>{try{const n=await fetch(t);if(n.ok)return[await n.text(),n.url]}catch{}throw e()},eo=(e,t)=>n=>t(e,n),to=e=>t=>{const n=e(t);if(n.renderer===null)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return n.renderer},no=e=>t=>{var n;return(n=e.get(t))!==null&&n!==void 0?n:0},ro=e=>t=>{const n=e(t);if(n.renderer===null)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return n.renderer},so=e=>t=>e.get(t),Z=()=>new DOMException("","InvalidStateError"),oo=e=>t=>{const n=e.get(t);if(n===void 0)throw Z();return n},ao=(e,t)=>n=>{let r=e.get(n);if(r!==void 0)return r;if(t===null)throw new Error("Missing the native OfflineAudioContext constructor.");return r=new t(1,1,44100),e.set(n,r),r},io=e=>t=>{const n=e.get(t);if(n===void 0)throw new Error("The context has no set of AudioWorkletNodes.");return n},co=()=>new DOMException("","InvalidAccessError"),uo=(e,t,n,r,s,o)=>a=>(c,i)=>{const u=e.get(c);if(u===void 0){if(!a&&o(c)){const d=r(c),{outputs:l}=n(c);for(const m of l)if(Me(m)){const w=r(m[0]);t(d,w,m[1],m[2])}else{const w=s(m[0]);d.disconnect(w,m[1])}}e.set(c,i)}else e.set(c,u+i)},lo=e=>t=>e!==null&&t instanceof e,fo=e=>t=>e!==null&&typeof e.AudioNode=="function"&&t instanceof e.AudioNode,ho=e=>t=>e!==null&&typeof e.AudioParam=="function"&&t instanceof e.AudioParam,po=e=>t=>e!==null&&t instanceof e,mo=e=>e!==null&&e.isSecureContext,go=(e,t,n,r)=>class extends e{constructor(o,a){const c=n(o),i=t(c,a);if(r(c))throw new TypeError;super(o,!0,i,null),this._nativeMediaStreamAudioSourceNode=i}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}},wo=(e,t,n,r,s)=>class extends r{constructor(a={}){if(s===null)throw new Error("Missing the native AudioContext constructor.");let c;try{c=new s(a)}catch(d){throw d.code===12&&d.message==="sampleRate is not in range"?t():d}if(c===null)throw n();if(!ys(a.latencyHint))throw new TypeError(`The provided value '${a.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(a.sampleRate!==void 0&&c.sampleRate!==a.sampleRate)throw t();super(c,2);const{latencyHint:i}=a,{sampleRate:u}=c;if(this._baseLatency=typeof c.baseLatency=="number"?c.baseLatency:i==="balanced"?512/u:i==="interactive"||i===void 0?256/u:i==="playback"?1024/u:Math.max(2,Math.min(128,Math.round(i*u/128)))*128/u,this._nativeAudioContext=c,s.name==="webkitAudioContext"?(this._nativeGainNode=c.createGain(),this._nativeOscillatorNode=c.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(c.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,c.state==="running"){this._state="suspended";const d=()=>{this._state==="suspended"&&(this._state=null),c.removeEventListener("statechange",d)};c.addEventListener("statechange",d)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){return this.state==="closed"?this._nativeAudioContext.close().then(()=>{throw e()}):(this._state==="suspended"&&(this._state=null),this._nativeAudioContext.close().then(()=>{this._nativeGainNode!==null&&this._nativeOscillatorNode!==null&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),_s(this)}))}resume(){return this._state==="suspended"?new Promise((a,c)=>{const i=()=>{this._nativeAudioContext.removeEventListener("statechange",i),this._nativeAudioContext.state==="running"?a():this.resume().then(a,c)};this._nativeAudioContext.addEventListener("statechange",i)}):this._nativeAudioContext.resume().catch(a=>{throw a===void 0||a.code===15?e():a})}suspend(){return this._nativeAudioContext.suspend().catch(a=>{throw a===void 0?e():a})}},vo=(e,t,n,r,s,o)=>class extends n{constructor(c,i){super(c),this._nativeContext=c,mn.set(this,c),r(c)&&s.set(c,new Set),this._destination=new e(this,i),this._listener=t(this,c),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(c){const i=typeof c=="function"?o(this,c):null;this._nativeContext.onstatechange=i;const u=this._nativeContext.onstatechange;this._onstatechange=u!==null&&u===i?c:u}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}},Kt=e=>{const t=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const n=e.decodeAudioData(t.buffer,()=>{});return n===void 0?!1:(n.catch(()=>{}),!0)}catch{}return!1},_o=(e,t)=>(n,r,s)=>{const o=new Set;return n.connect=(a=>(c,i=0,u=0)=>{const d=o.size===0;if(t(c))return a.call(n,c,i,u),e(o,[c,i,u],l=>l[0]===c&&l[1]===i&&l[2]===u,!0),d&&r(),c;a.call(n,c,i),e(o,[c,i],l=>l[0]===c&&l[1]===i,!0),d&&r()})(n.connect),n.disconnect=(a=>(c,i,u)=>{const d=o.size>0;if(c===void 0)a.apply(n),o.clear();else if(typeof c=="number"){a.call(n,c);for(const m of o)m[1]===c&&o.delete(m)}else{t(c)?a.call(n,c,i,u):a.call(n,c,i);for(const m of o)m[0]===c&&(i===void 0||m[1]===i)&&(u===void 0||m[2]===u)&&o.delete(m)}const l=o.size===0;d&&l&&s()})(n.disconnect),n},oe=(e,t,n)=>{const r=t[n];r!==void 0&&r!==e[n]&&(e[n]=r)},Ne=(e,t)=>{oe(e,t,"channelCount"),oe(e,t,"channelCountMode"),oe(e,t,"channelInterpretation")},yo=e=>e===null?null:e.hasOwnProperty("AudioBuffer")?e.AudioBuffer:null,_t=(e,t,n)=>{const r=t[n];r!==void 0&&r!==e[n].value&&(e[n].value=r)},Eo=e=>{e.start=(t=>{let n=!1;return(r=0,s=0,o)=>{if(n)throw Z();t.call(e,r,s,o),n=!0}})(e.start)},Rn=e=>{e.start=(t=>(n=0,r=0,s)=>{if(typeof s=="number"&&s<0||r<0||n<0)throw new RangeError("The parameters can't be negative.");t.call(e,n,r,s)})(e.start)},On=e=>{e.stop=(t=>(n=0)=>{if(n<0)throw new RangeError("The parameter can't be negative.");t.call(e,n)})(e.stop)},bo=(e,t,n,r,s,o,a,c,i,u,d)=>(l,m)=>{const w=l.createBufferSource();return Ne(w,m),_t(w,m,"playbackRate"),oe(w,m,"buffer"),oe(w,m,"loop"),oe(w,m,"loopEnd"),oe(w,m,"loopStart"),t(n,()=>n(l))||Eo(w),t(r,()=>r(l))||i(w),t(s,()=>s(l))||u(w,l),t(o,()=>o(l))||Rn(w),t(a,()=>a(l))||d(w,l),t(c,()=>c(l))||On(w),e(l,w),w},Ao=e=>e===null?null:e.hasOwnProperty("AudioContext")?e.AudioContext:e.hasOwnProperty("webkitAudioContext")?e.webkitAudioContext:null,Co=(e,t)=>(n,r,s)=>{const o=n.destination;if(o.channelCount!==r)try{o.channelCount=r}catch{}s&&o.channelCountMode!=="explicit"&&(o.channelCountMode="explicit"),o.maxChannelCount===0&&Object.defineProperty(o,"maxChannelCount",{value:r});const a=e(n,{channelCount:r,channelCountMode:o.channelCountMode,channelInterpretation:o.channelInterpretation,gain:1});return t(a,"channelCount",c=>()=>c.call(a),c=>i=>{c.call(a,i);try{o.channelCount=i}catch(u){if(i>o.maxChannelCount)throw u}}),t(a,"channelCountMode",c=>()=>c.call(a),c=>i=>{c.call(a,i),o.channelCountMode=i}),t(a,"channelInterpretation",c=>()=>c.call(a),c=>i=>{c.call(a,i),o.channelInterpretation=i}),Object.defineProperty(a,"maxChannelCount",{get:()=>o.maxChannelCount}),a.connect(o),a},To=e=>e===null?null:e.hasOwnProperty("AudioWorkletNode")?e.AudioWorkletNode:null,Mo=e=>{const{port1:t}=new MessageChannel;try{t.postMessage(e)}finally{t.close()}},No=(e,t,n,r,s)=>(o,a,c,i,u,d)=>{if(c!==null)try{const l=new c(o,i,d),m=new Map;let w=null;if(Object.defineProperties(l,{channelCount:{get:()=>d.channelCount,set:()=>{throw e()}},channelCountMode:{get:()=>"explicit",set:()=>{throw e()}},onprocessorerror:{get:()=>w,set:p=>{typeof w=="function"&&l.removeEventListener("processorerror",w),w=typeof p=="function"?p:null,typeof w=="function"&&l.addEventListener("processorerror",w)}}}),l.addEventListener=(p=>(...f)=>{if(f[0]==="processorerror"){const g=typeof f[1]=="function"?f[1]:typeof f[1]=="object"&&f[1]!==null&&typeof f[1].handleEvent=="function"?f[1].handleEvent:null;if(g!==null){const h=m.get(f[1]);h!==void 0?f[1]=h:(f[1]=A=>{A.type==="error"?(Object.defineProperties(A,{type:{value:"processorerror"}}),g(A)):g(new ErrorEvent(f[0],{...A}))},m.set(g,f[1]))}}return p.call(l,"error",f[1],f[2]),p.call(l,...f)})(l.addEventListener),l.removeEventListener=(p=>(...f)=>{if(f[0]==="processorerror"){const g=m.get(f[1]);g!==void 0&&(m.delete(f[1]),f[1]=g)}return p.call(l,"error",f[1],f[2]),p.call(l,f[0],f[1],f[2])})(l.removeEventListener),d.numberOfOutputs!==0){const p=n(o,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return l.connect(p).connect(o.destination),s(l,()=>p.disconnect(),()=>p.connect(o.destination))}return l}catch(l){throw l.code===11?r():l}if(u===void 0)throw r();return Mo(d),t(o,a,u,d)},Ro=(e,t)=>e===null?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(e*t))))),Oo=e=>new Promise((t,n)=>{const{port1:r,port2:s}=new MessageChannel;r.onmessage=({data:o})=>{r.close(),s.close(),t(o)},r.onmessageerror=({data:o})=>{r.close(),s.close(),n(o)},s.postMessage(e)}),ko=async(e,t)=>{const n=await Oo(t);return new e(n)},Io=(e,t,n,r)=>{let s=it.get(e);s===void 0&&(s=new WeakMap,it.set(e,s));const o=ko(n,r);return s.set(t,o),o},So=(e,t,n,r,s,o,a,c,i,u,d,l,m)=>(w,p,f,g)=>{if(g.numberOfInputs===0&&g.numberOfOutputs===0)throw i();const h=Array.isArray(g.outputChannelCount)?g.outputChannelCount:Array.from(g.outputChannelCount);if(h.some(C=>C<1))throw i();if(h.length!==g.numberOfOutputs)throw t();if(g.channelCountMode!=="explicit")throw i();const A=g.channelCount*g.numberOfInputs,v=h.reduce((C,O)=>C+O,0),T=f.parameterDescriptors===void 0?0:f.parameterDescriptors.length;if(A+T>6||v>6)throw i();const E=new MessageChannel,b=[],y=[];for(let C=0;C<g.numberOfInputs;C+=1)b.push(a(w,{channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,gain:1})),y.push(s(w,{channelCount:g.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:g.channelCount}));const _=[];if(f.parameterDescriptors!==void 0)for(const{defaultValue:C,maxValue:O,minValue:$,name:F}of f.parameterDescriptors){const W=o(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:g.parameterData[F]!==void 0?g.parameterData[F]:C===void 0?0:C});Object.defineProperties(W.offset,{defaultValue:{get:()=>C===void 0?0:C},maxValue:{get:()=>O===void 0?gt:O},minValue:{get:()=>$===void 0?je:$}}),_.push(W)}const M=r(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,A+T)}),I=Ro(p,w.sampleRate),N=c(w,I,A+T,Math.max(1,v)),L=s(w,{channelCount:Math.max(1,v),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,v)}),U=[];for(let C=0;C<g.numberOfOutputs;C+=1)U.push(r(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:h[C]}));for(let C=0;C<g.numberOfInputs;C+=1){b[C].connect(y[C]);for(let O=0;O<g.channelCount;O+=1)y[C].connect(M,O,C*g.channelCount+O)}const P=new Mn(f.parameterDescriptors===void 0?[]:f.parameterDescriptors.map(({name:C},O)=>{const $=_[O];return $.connect(M,0,A+O),$.start(0),[C,$.offset]}));M.connect(N);let D=g.channelInterpretation,k=null;const B=g.numberOfOutputs===0?[N]:U,x={get bufferSize(){return I},get channelCount(){return g.channelCount},set channelCount(C){throw n()},get channelCountMode(){return g.channelCountMode},set channelCountMode(C){throw n()},get channelInterpretation(){return D},set channelInterpretation(C){for(const O of b)O.channelInterpretation=C;D=C},get context(){return N.context},get inputs(){return b},get numberOfInputs(){return g.numberOfInputs},get numberOfOutputs(){return g.numberOfOutputs},get onprocessorerror(){return k},set onprocessorerror(C){typeof k=="function"&&x.removeEventListener("processorerror",k),k=typeof C=="function"?C:null,typeof k=="function"&&x.addEventListener("processorerror",k)},get parameters(){return P},get port(){return E.port2},addEventListener(...C){return N.addEventListener(C[0],C[1],C[2])},connect:e.bind(null,B),disconnect:u.bind(null,B),dispatchEvent(...C){return N.dispatchEvent(C[0])},removeEventListener(...C){return N.removeEventListener(C[0],C[1],C[2])}},R=new Map;E.port1.addEventListener=(C=>(...O)=>{if(O[0]==="message"){const $=typeof O[1]=="function"?O[1]:typeof O[1]=="object"&&O[1]!==null&&typeof O[1].handleEvent=="function"?O[1].handleEvent:null;if($!==null){const F=R.get(O[1]);F!==void 0?O[1]=F:(O[1]=W=>{d(w.currentTime,w.sampleRate,()=>$(W))},R.set($,O[1]))}}return C.call(E.port1,O[0],O[1],O[2])})(E.port1.addEventListener),E.port1.removeEventListener=(C=>(...O)=>{if(O[0]==="message"){const $=R.get(O[1]);$!==void 0&&(R.delete(O[1]),O[1]=$)}return C.call(E.port1,O[0],O[1],O[2])})(E.port1.removeEventListener);let S=null;Object.defineProperty(E.port1,"onmessage",{get:()=>S,set:C=>{typeof S=="function"&&E.port1.removeEventListener("message",S),S=typeof C=="function"?C:null,typeof S=="function"&&(E.port1.addEventListener("message",S),E.port1.start())}}),f.prototype.port=E.port1;let V=null;Io(w,x,f,g).then(C=>V=C);const fe=Ve(g.numberOfInputs,g.channelCount),he=Ve(g.numberOfOutputs,h),pe=f.parameterDescriptors===void 0?[]:f.parameterDescriptors.reduce((C,{name:O})=>({...C,[O]:new Float32Array(128)}),{});let j=!0;const X=()=>{g.numberOfOutputs>0&&N.disconnect(L);for(let C=0,O=0;C<g.numberOfOutputs;C+=1){const $=U[C];for(let F=0;F<h[C];F+=1)L.disconnect($,O+F,F);O+=h[C]}},Re=new Map;N.onaudioprocess=({inputBuffer:C,outputBuffer:O})=>{if(V!==null){const $=l(x);for(let F=0;F<I;F+=128){for(let W=0;W<g.numberOfInputs;W+=1)for(let G=0;G<g.channelCount;G+=1)xe(C,fe[W],G,G,F);f.parameterDescriptors!==void 0&&f.parameterDescriptors.forEach(({name:W},G)=>{xe(C,pe,W,A+G,F)});for(let W=0;W<g.numberOfInputs;W+=1)for(let G=0;G<h[W];G+=1)he[W][G].byteLength===0&&(he[W][G]=new Float32Array(128));try{const W=fe.map((H,te)=>{if($[te].size>0)return Re.set(te,I/128),H;const Ze=Re.get(te);return Ze===void 0?[]:(H.every(rr=>rr.every(sr=>sr===0))&&(Ze===1?Re.delete(te):Re.set(te,Ze-1)),H)});j=d(w.currentTime+F/w.sampleRate,w.sampleRate,()=>V.process(W,he,pe));for(let H=0,te=0;H<g.numberOfOutputs;H+=1){for(let _e=0;_e<h[H];_e+=1)Nn(O,he[H],_e,te+_e,F);te+=h[H]}}catch(W){j=!1,x.dispatchEvent(new ErrorEvent("processorerror",{colno:W.colno,filename:W.filename,lineno:W.lineno,message:W.message}))}if(!j){for(let W=0;W<g.numberOfInputs;W+=1){b[W].disconnect(y[W]);for(let G=0;G<g.channelCount;G+=1)y[F].disconnect(M,G,W*g.channelCount+G)}if(f.parameterDescriptors!==void 0){const W=f.parameterDescriptors.length;for(let G=0;G<W;G+=1){const H=_[G];H.disconnect(M,0,A+G),H.stop()}}M.disconnect(N),N.onaudioprocess=null,He?X():It();break}}}};let He=!1;const Ye=a(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),kt=()=>N.connect(Ye).connect(w.destination),It=()=>{N.disconnect(Ye),Ye.disconnect()},tr=()=>{if(j){It(),g.numberOfOutputs>0&&N.connect(L);for(let C=0,O=0;C<g.numberOfOutputs;C+=1){const $=U[C];for(let F=0;F<h[C];F+=1)L.connect($,O+F,F);O+=h[C]}}He=!0},nr=()=>{j&&(kt(),X()),He=!1};return kt(),m(x,tr,nr)},Lo=(e,t)=>(n,r)=>{const s=n.createChannelMerger(r.numberOfInputs);return e!==null&&e.name==="webkitAudioContext"&&t(n,s),Ne(s,r),s},Uo=e=>{const t=e.numberOfOutputs;Object.defineProperty(e,"channelCount",{get:()=>t,set:n=>{if(n!==t)throw Z()}}),Object.defineProperty(e,"channelCountMode",{get:()=>"explicit",set:n=>{if(n!=="explicit")throw Z()}}),Object.defineProperty(e,"channelInterpretation",{get:()=>"discrete",set:n=>{if(n!=="discrete")throw Z()}})},kn=(e,t)=>{const n=e.createChannelSplitter(t.numberOfOutputs);return Ne(n,t),Uo(n),n},Po=(e,t,n,r,s)=>(o,a)=>{if(o.createConstantSource===void 0)return n(o,a);const c=o.createConstantSource();return Ne(c,a),_t(c,a,"offset"),t(r,()=>r(o))||Rn(c),t(s,()=>s(o))||On(c),e(o,c),c},In=(e,t)=>(e.connect=t.connect.bind(t),e.disconnect=t.disconnect.bind(t),e),Bo=(e,t,n,r)=>(s,{offset:o,...a})=>{const c=s.createBuffer(1,2,44100),i=t(s,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),u=n(s,{...a,gain:o}),d=c.getChannelData(0);d[0]=1,d[1]=1,i.buffer=c,i.loop=!0;const l={get bufferSize(){},get channelCount(){return u.channelCount},set channelCount(p){u.channelCount=p},get channelCountMode(){return u.channelCountMode},set channelCountMode(p){u.channelCountMode=p},get channelInterpretation(){return u.channelInterpretation},set channelInterpretation(p){u.channelInterpretation=p},get context(){return u.context},get inputs(){return[]},get numberOfInputs(){return i.numberOfInputs},get numberOfOutputs(){return u.numberOfOutputs},get offset(){return u.gain},get onended(){return i.onended},set onended(p){i.onended=p},addEventListener(...p){return i.addEventListener(p[0],p[1],p[2])},dispatchEvent(...p){return i.dispatchEvent(p[0])},removeEventListener(...p){return i.removeEventListener(p[0],p[1],p[2])},start(p=0){i.start.call(i,p)},stop(p=0){i.stop.call(i,p)}},m=()=>i.connect(u),w=()=>i.disconnect(u);return e(s,i),r(In(l,u),m,w)},se=(e,t)=>{const n=e.createGain();return Ne(n,t),_t(n,t,"gain"),n},Do=(e,{mediaStream:t})=>{const n=t.getAudioTracks();n.sort((o,a)=>o.id<a.id?-1:o.id>a.id?1:0);const r=n.slice(0,1),s=e.createMediaStreamSource(new MediaStream(r));return Object.defineProperty(s,"mediaStream",{value:t}),s},Wo=e=>e===null?null:e.hasOwnProperty("OfflineAudioContext")?e.OfflineAudioContext:e.hasOwnProperty("webkitOfflineAudioContext")?e.webkitOfflineAudioContext:null,yt=(e,t,n,r)=>e.createScriptProcessor(t,n,r),de=()=>new DOMException("","NotSupportedError"),xo=(e,t)=>(n,r,s)=>(e(r).replay(s),t(r,n,s)),Vo=(e,t,n)=>async(r,s,o)=>{const a=e(r);await Promise.all(a.activeInputs.map((c,i)=>Array.from(c).map(async([u,d])=>{const m=await t(u).render(u,s),w=r.context.destination;!n(u)&&(r!==w||!n(r))&&m.connect(o,d,i)})).reduce((c,i)=>[...c,...i],[]))},Fo=(e,t,n)=>async(r,s,o)=>{const a=t(r);await Promise.all(Array.from(a.activeInputs).map(async([c,i])=>{const d=await e(c).render(c,s);n(c)||d.connect(o,i)}))},jo=(e,t,n,r)=>s=>e(Kt,()=>Kt(s))?Promise.resolve(e(r,r)).then(o=>{if(!o){const a=n(s,512,0,1);s.oncomplete=()=>{a.onaudioprocess=null,a.disconnect()},a.onaudioprocess=()=>s.currentTime,a.connect(s.destination)}return s.startRendering()}):new Promise(o=>{const a=t(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});s.oncomplete=c=>{a.disconnect(),o(c.renderedBuffer)},a.connect(s.destination),s.startRendering()}),Go=e=>(t,n)=>{e.set(t,n)},qo=e=>()=>{if(e===null)return!1;try{new e({length:1,sampleRate:44100})}catch{return!1}return!0},$o=(e,t)=>async()=>{if(e===null)return!0;if(t===null)return!1;const n=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),r=new t(1,128,44100),s=URL.createObjectURL(n);let o=!1,a=!1;try{await r.audioWorklet.addModule(s);const c=new e(r,"a",{numberOfOutputs:0}),i=r.createOscillator();c.port.onmessage=()=>o=!0,c.onprocessorerror=()=>a=!0,i.connect(c),i.start(0),await r.startRendering(),await new Promise(u=>setTimeout(u))}catch{}finally{URL.revokeObjectURL(s)}return o&&!a},zo=(e,t)=>()=>{if(t===null)return Promise.resolve(!1);const n=new t(1,1,44100),r=e(n,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(s=>{n.oncomplete=()=>{r.disconnect(),s(n.currentTime!==0)},n.startRendering()})},Xo=()=>new DOMException("","UnknownError"),Ho=()=>typeof window>"u"?null:window,Yo=(e,t)=>n=>{n.copyFromChannel=(r,s,o=0)=>{const a=e(o),c=e(s);if(c>=n.numberOfChannels)throw t();const i=n.length,u=n.getChannelData(c),d=r.length;for(let l=a<0?-a:0;l+a<i&&l<d;l+=1)r[l]=u[l+a]},n.copyToChannel=(r,s,o=0)=>{const a=e(o),c=e(s);if(c>=n.numberOfChannels)throw t();const i=n.length,u=n.getChannelData(c),d=r.length;for(let l=a<0?-a:0;l+a<i&&l<d;l+=1)u[l+a]=r[l]}},Zo=e=>t=>{t.copyFromChannel=(n=>(r,s,o=0)=>{const a=e(o),c=e(s);if(a<t.length)return n.call(t,r,c,a)})(t.copyFromChannel),t.copyToChannel=(n=>(r,s,o=0)=>{const a=e(o),c=e(s);if(a<t.length)return n.call(t,r,c,a)})(t.copyToChannel)},Qo=e=>(t,n)=>{const r=n.createBuffer(1,1,44100);t.buffer===null&&(t.buffer=r),e(t,"buffer",s=>()=>{const o=s.call(t);return o===r?null:o},s=>o=>s.call(t,o===null?r:o))},Ko=(e,t)=>(n,r)=>{r.channelCount=1,r.channelCountMode="explicit",Object.defineProperty(r,"channelCount",{get:()=>1,set:()=>{throw e()}}),Object.defineProperty(r,"channelCountMode",{get:()=>"explicit",set:()=>{throw e()}});const s=n.createBufferSource();t(r,()=>{const c=r.numberOfInputs;for(let i=0;i<c;i+=1)s.connect(r,0,i)},()=>s.disconnect(r))},Jo=(e,t,n)=>e.copyFromChannel===void 0?e.getChannelData(n)[0]:(e.copyFromChannel(t,n),t[0]),Et=(e,t,n,r)=>{let s=e;for(;!s.hasOwnProperty(t);)s=Object.getPrototypeOf(s);const{get:o,set:a}=Object.getOwnPropertyDescriptor(s,t);Object.defineProperty(e,t,{get:n(o),set:r(a)})},ea=e=>({...e,outputChannelCount:e.outputChannelCount!==void 0?e.outputChannelCount:e.numberOfInputs===1&&e.numberOfOutputs===1?[e.channelCount]:Array.from({length:e.numberOfOutputs},()=>1)}),Sn=(e,t,n)=>{try{e.setValueAtTime(t,n)}catch(r){if(r.code!==9)throw r;Sn(e,t,n+1e-7)}},ta=e=>{const t=e.createBufferSource();t.start();try{t.start()}catch{return!0}return!1},na=e=>{const t=e.createBufferSource(),n=e.createBuffer(1,1,44100);t.buffer=n;try{t.start(0,1)}catch{return!1}return!0},ra=e=>{const t=e.createBufferSource();t.start();try{t.stop()}catch{return!1}return!0},Ln=e=>{const t=e.createOscillator();try{t.start(-1)}catch(n){return n instanceof RangeError}return!1},sa=e=>{const t=e.createBuffer(1,1,44100),n=e.createBufferSource();n.buffer=t,n.start(),n.stop();try{return n.stop(),!0}catch{return!1}},Un=e=>{const t=e.createOscillator();try{t.stop(-1)}catch(n){return n instanceof RangeError}return!1},oa=e=>{const{port1:t,port2:n}=new MessageChannel;try{t.postMessage(e)}finally{t.close(),n.close()}},aa=e=>{e.start=(t=>(n=0,r=0,s)=>{const o=e.buffer,a=o===null?r:Math.min(o.duration,r);o!==null&&a>o.duration-.5/e.context.sampleRate?t.call(e,n,0,0):t.call(e,n,a,s)})(e.start)},ia=(e,t)=>{const n=t.createGain();e.connect(n);const r=(s=>()=>{s.call(e,n),e.removeEventListener("ended",r)})(e.disconnect);e.addEventListener("ended",r),In(e,n),e.stop=(s=>{let o=!1;return(a=0)=>{if(o)try{s.call(e,a)}catch{n.gain.setValueAtTime(0,a)}else s.call(e,a),o=!0}})(e.stop)},Ge=(e,t)=>n=>{const r={value:e};return Object.defineProperties(n,{currentTarget:r,target:r}),typeof t=="function"?t.call(e,n):t.handleEvent.call(e,n)},ca=Kr(le),ua=ss(le),la=$s(Fe),da=new WeakMap,fa=no(da),we=Vs(new Map,new WeakMap),K=Ho(),Pn=to(z),bt=Vo(z,Pn,ie),ce=oo(mn),ve=Wo(K),ee=po(ve),Bn=new WeakMap,Dn=Qs(Ge),qe=Ao(K),ha=lo(qe),Wn=fo(K),pa=ho(K),Ae=To(K),$e=Ss(Jr(dn),rs(ca,ua,lt,la,dt,z,fa,Ce,Y,le,ae,ie,Se),we,uo(ot,dt,z,Y,be,ae),ue,co,de,qs(lt,ot,z,Y,be,ce,ae,ee),Hs(Bn,z,Q),Dn,ce,ha,Wn,pa,ee,Ae),ma=new WeakSet,Jt=yo(K),xn=Gs(new Uint32Array(1)),ga=Yo(xn,ue),wa=Zo(xn),va=us(ma,we,de,Jt,ve,qo(Jt),ga,wa),At=os(se),Vn=Fo(Pn,Te,ie),Fn=Fs(Vn),ze=bo(At,we,ta,na,ra,Ln,sa,Un,aa,Qo(Et),ia),jn=xo(ro(Te),Vn),_a=fs(Fn,ze,Y,jn,bt),Ct=Ls(es(hn),Bn,pn,Us,zr,Xr,Hr,Yr,Zr,nt,un,qe,Sn),ya=ds($e,_a,Ct,Z,ze,ce,ee,Ge),Ea=Es($e,bs,ue,Z,Co(se,Et),ce,ee,bt),Xe=_o(le,Wn),ba=Ko(Z,Xe),Tt=Lo(qe,ba),Aa=Bo(At,ze,se,Xe),Mt=Po(At,we,Aa,Ln,Un),Ca=jo(we,se,yt,zo(se,ve)),Ta=As(Ct,Tt,Mt,yt,de,Jo,ee,Et),Gn=new WeakMap,Ma=vo(Ea,Ta,Dn,ee,Gn,Ge),qn=mo(K),Nt=Ks(K),$n=new WeakMap,Na=ao($n,ve),en=qn?ns(we,de,Zs(K),Nt,Js(Qr),ce,Na,ee,Ae,new WeakMap,new WeakMap,$o(Ae,ve),K):void 0,Ra=go($e,Do,ce,ee),zn=io(Gn),Oa=as(zn),Xn=js(ue),ka=zs(zn),Hn=Ys(ue),Yn=new WeakMap,Ia=eo(Yn,Q),Sa=So(Xn,ue,Z,Tt,kn,Mt,se,yt,de,Hn,Nt,Ia,Xe),La=No(Z,Sa,se,de,Xe),Ua=xs(Fn,Xn,ze,Tt,kn,Mt,se,ka,Hn,Nt,Y,Ae,ve,jn,bt,Ca),Pa=so($n),Ba=Go(Yn),tn=qn?Bs(Oa,$e,Ct,Ua,La,z,Pa,ce,ee,Ae,ea,Ba,oa,Ge):void 0,Da=wo(Z,de,Xo,Ma,qe),Zn="Missing AudioWorklet support. Maybe this is not running in a secure context.",Wa=async(e,t,n,r,s)=>{const{encoderInstanceId:o,port:a}=await an(s,t.sampleRate);if(tn===void 0)throw new Error(Zn);const c=new ya(t,{buffer:e}),i=new Ra(t,{mediaStream:r}),u=jr(tn,t,{channelCount:n});return{audioBufferSourceNode:c,encoderInstanceId:o,mediaStreamAudioSourceNode:i,port:a,recorderAudioWorkletNode:u}},xa=(e,t,n,r)=>(s,o,a)=>{var c;const i=(c=o.getAudioTracks()[0])===null||c===void 0?void 0:c.getSettings().sampleRate,u=new Da({latencyHint:"playback",sampleRate:i}),d=Math.max(1024,Math.ceil(u.baseLatency*u.sampleRate)),l=new va({length:d,sampleRate:u.sampleRate}),m=[],w=Fr(_=>{if(en===void 0)throw new Error(Zn);return en(u,_)});let p=null,f=null,g=null,h=null,A=!0;const v=_=>{s.dispatchEvent(e("dataavailable",{data:new Blob(_,{type:a})}))},T=async(_,M)=>{const I=await Le(_,M);g===null?m.push(...I):(v(I),h=T(_,M))},E=()=>(A=!0,u.resume()),b=()=>{g!==null&&(p!==null&&(o.removeEventListener("addtrack",p),o.removeEventListener("removetrack",p)),f!==null&&clearTimeout(f),g.then(async({encoderInstanceId:_,mediaStreamAudioSourceNode:M,recorderAudioWorkletNode:I})=>{h!==null&&(h.catch(()=>{}),h=null),await I.stop(),M.disconnect(I);const N=await Le(_,null);g===null&&await y(),v([...m,...N]),m.length=0,s.dispatchEvent(new Event("stop"))}),g=null)},y=()=>(A=!1,u.suspend());return y(),{get mimeType(){return a},get state(){return g===null?"inactive":A?"recording":"paused"},pause(){if(g===null)throw n();A&&(y(),s.dispatchEvent(new Event("pause")))},resume(){if(g===null)throw n();A||(E(),s.dispatchEvent(new Event("resume")))},start(_){var M;if(g!==null)throw n();if(o.getVideoTracks().length>0)throw r();s.dispatchEvent(new Event("start"));const I=o.getAudioTracks(),N=I.length===0?2:(M=I[0].getSettings().channelCount)!==null&&M!==void 0?M:2;g=Promise.all([E(),w.then(()=>Wa(l,u,N,o,a))]).then(async([,{audioBufferSourceNode:U,encoderInstanceId:P,mediaStreamAudioSourceNode:D,port:k,recorderAudioWorkletNode:B}])=>(D.connect(B),await new Promise(x=>{U.onended=x,U.connect(B),U.start(u.currentTime+d/u.sampleRate)}),U.disconnect(B),await B.record(k),_!==void 0&&(h=T(P,_)),{encoderInstanceId:P,mediaStreamAudioSourceNode:D,recorderAudioWorkletNode:B}));const L=o.getTracks();p=()=>{b(),s.dispatchEvent(new ErrorEvent("error",{error:t()}))},o.addEventListener("addtrack",p),o.addEventListener("removetrack",p),f=setInterval(()=>{const U=o.getTracks();(U.length!==L.length||U.some((P,D)=>P!==L[D]))&&p!==null&&p()},1e3)},stop:b}};class et{constructor(t,n=0,r){if(n<0||r!==void 0&&r<0)throw new RangeError;const s=t.reduce((d,l)=>d+l.byteLength,0);if(n>s||r!==void 0&&n+r>s)throw new RangeError;const o=[],a=r===void 0?s-n:r,c=[];let i=0,u=n;for(const d of t)if(c.length===0)if(d.byteLength>u){i=d.byteLength-u;const l=i>a?a:i;o.push(new DataView(d,u,l)),c.push(d)}else u-=d.byteLength;else if(i<a){i+=d.byteLength;const l=i>a?d.byteLength-i+a:d.byteLength;o.push(new DataView(d,0,l)),c.push(d)}this._buffers=c,this._byteLength=a,this._byteOffset=u,this._dataViews=o,this._internalBuffer=new DataView(new ArrayBuffer(8))}get buffers(){return this._buffers}get byteLength(){return this._byteLength}get byteOffset(){return this._byteOffset}getFloat32(t,n){return this._internalBuffer.setUint8(0,this.getUint8(t+0)),this._internalBuffer.setUint8(1,this.getUint8(t+1)),this._internalBuffer.setUint8(2,this.getUint8(t+2)),this._internalBuffer.setUint8(3,this.getUint8(t+3)),this._internalBuffer.getFloat32(0,n)}getFloat64(t,n){return this._internalBuffer.setUint8(0,this.getUint8(t+0)),this._internalBuffer.setUint8(1,this.getUint8(t+1)),this._internalBuffer.setUint8(2,this.getUint8(t+2)),this._internalBuffer.setUint8(3,this.getUint8(t+3)),this._internalBuffer.setUint8(4,this.getUint8(t+4)),this._internalBuffer.setUint8(5,this.getUint8(t+5)),this._internalBuffer.setUint8(6,this.getUint8(t+6)),this._internalBuffer.setUint8(7,this.getUint8(t+7)),this._internalBuffer.getFloat64(0,n)}getInt16(t,n){return this._internalBuffer.setUint8(0,this.getUint8(t+0)),this._internalBuffer.setUint8(1,this.getUint8(t+1)),this._internalBuffer.getInt16(0,n)}getInt32(t,n){return this._internalBuffer.setUint8(0,this.getUint8(t+0)),this._internalBuffer.setUint8(1,this.getUint8(t+1)),this._internalBuffer.setUint8(2,this.getUint8(t+2)),this._internalBuffer.setUint8(3,this.getUint8(t+3)),this._internalBuffer.getInt32(0,n)}getInt8(t){const[n,r]=this._findDataViewWithOffset(t);return n.getInt8(t-r)}getUint16(t,n){return this._internalBuffer.setUint8(0,this.getUint8(t+0)),this._internalBuffer.setUint8(1,this.getUint8(t+1)),this._internalBuffer.getUint16(0,n)}getUint32(t,n){return this._internalBuffer.setUint8(0,this.getUint8(t+0)),this._internalBuffer.setUint8(1,this.getUint8(t+1)),this._internalBuffer.setUint8(2,this.getUint8(t+2)),this._internalBuffer.setUint8(3,this.getUint8(t+3)),this._internalBuffer.getUint32(0,n)}getUint8(t){const[n,r]=this._findDataViewWithOffset(t);return n.getUint8(t-r)}setFloat32(t,n,r){this._internalBuffer.setFloat32(0,n,r),this.setUint8(t,this._internalBuffer.getUint8(0)),this.setUint8(t+1,this._internalBuffer.getUint8(1)),this.setUint8(t+2,this._internalBuffer.getUint8(2)),this.setUint8(t+3,this._internalBuffer.getUint8(3))}setFloat64(t,n,r){this._internalBuffer.setFloat64(0,n,r),this.setUint8(t,this._internalBuffer.getUint8(0)),this.setUint8(t+1,this._internalBuffer.getUint8(1)),this.setUint8(t+2,this._internalBuffer.getUint8(2)),this.setUint8(t+3,this._internalBuffer.getUint8(3)),this.setUint8(t+4,this._internalBuffer.getUint8(4)),this.setUint8(t+5,this._internalBuffer.getUint8(5)),this.setUint8(t+6,this._internalBuffer.getUint8(6)),this.setUint8(t+7,this._internalBuffer.getUint8(7))}setInt16(t,n,r){this._internalBuffer.setInt16(0,n,r),this.setUint8(t,this._internalBuffer.getUint8(0)),this.setUint8(t+1,this._internalBuffer.getUint8(1))}setInt32(t,n,r){this._internalBuffer.setInt32(0,n,r),this.setUint8(t,this._internalBuffer.getUint8(0)),this.setUint8(t+1,this._internalBuffer.getUint8(1)),this.setUint8(t+2,this._internalBuffer.getUint8(2)),this.setUint8(t+3,this._internalBuffer.getUint8(3))}setInt8(t,n){const[r,s]=this._findDataViewWithOffset(t);r.setInt8(t-s,n)}setUint16(t,n,r){this._internalBuffer.setUint16(0,n,r),this.setUint8(t,this._internalBuffer.getUint8(0)),this.setUint8(t+1,this._internalBuffer.getUint8(1))}setUint32(t,n,r){this._internalBuffer.setUint32(0,n,r),this.setUint8(t,this._internalBuffer.getUint8(0)),this.setUint8(t+1,this._internalBuffer.getUint8(1)),this.setUint8(t+2,this._internalBuffer.getUint8(2)),this.setUint8(t+3,this._internalBuffer.getUint8(3))}setUint8(t,n){const[r,s]=this._findDataViewWithOffset(t);r.setUint8(t-s,n)}_findDataViewWithOffset(t){let n=0;for(const r of this._dataViews){const s=n+r.byteLength;if(t>=n&&t<s)return[r,n];n=s}throw new RangeError}}const Va=(e,t,n)=>(r,s,o,a)=>{const c=[],i=new s(o,{mimeType:"audio/webm;codecs=pcm"});let u=null,d=()=>{};const l=p=>{r.dispatchEvent(e("dataavailable",{data:new Blob(p,{type:a})}))},m=async(p,f)=>{const g=await Le(p,f);i.state==="inactive"?c.push(...g):(l(g),u=m(p,f))},w=()=>{i.state!=="inactive"&&(u!==null&&(u.catch(()=>{}),u=null),d(),d=()=>{},i.stop())};return i.addEventListener("error",p=>{w(),r.dispatchEvent(new ErrorEvent("error",{error:p.error}))}),i.addEventListener("pause",()=>r.dispatchEvent(new Event("pause"))),i.addEventListener("resume",()=>r.dispatchEvent(new Event("resume"))),i.addEventListener("start",()=>r.dispatchEvent(new Event("start"))),{get mimeType(){return a},get state(){return i.state},pause(){return i.pause()},resume(){return i.resume()},start(p){const[f]=o.getAudioTracks();if(f!==void 0&&i.state==="inactive"){const{channelCount:g,sampleRate:h}=f.getSettings();if(g===void 0)throw new Error("The channelCount is not defined.");if(h===void 0)throw new Error("The sampleRate is not defined.");let A=!1,v=!1,T=0,E=an(a,h);d=()=>{v=!0};const b=cn(i,"dataavailable")(({data:y})=>{T+=1;const _=y.arrayBuffer();E=E.then(async({dataView:M=null,elementType:I=null,encoderInstanceId:N,port:L})=>{const U=await _;T-=1;const P=M===null?new et([U]):new et([...M.buffers,U],M.byteOffset);if(!A&&i.state==="recording"&&!v){const R=n(P,0);if(R===null)return{dataView:P,elementType:I,encoderInstanceId:N,port:L};const{value:S}=R;if(S!==172351395)return{dataView:M,elementType:I,encoderInstanceId:N,port:L};A=!0}const{currentElementType:D,offset:k,contents:B}=t(P,I,g),x=k<P.byteLength?new et(P.buffers,P.byteOffset+k):null;return B.forEach(R=>L.postMessage(R,R.map(({buffer:S})=>S))),T===0&&(i.state==="inactive"||v)&&(Le(N,null).then(R=>{l([...c,...R]),c.length=0,r.dispatchEvent(new Event("stop"))}),L.postMessage([]),L.close(),b()),{dataView:x,elementType:D,encoderInstanceId:N,port:L}})});p!==void 0&&E.then(({encoderInstanceId:y})=>{v||(u=m(y,p))})}i.start(100)},stop:w}},Fa=()=>typeof window>"u"?null:window,Qn=(e,t)=>{if(t>=e.byteLength)return null;const n=e.getUint8(t);if(n>127)return 1;if(n>63)return 2;if(n>31)return 3;if(n>15)return 4;if(n>7)return 5;if(n>3)return 6;if(n>1)return 7;if(n>0)return 8;const r=Qn(e,t+1);return r===null?null:r+8},ja=(e,t)=>n=>{const r={value:e};return Object.defineProperties(n,{currentTarget:r,target:r}),typeof t=="function"?t.call(e,n):t.handleEvent.call(e,n)},Kn=[],Rt=Fa(),Ga=Cr(Rt),Jn=wr(Ga),qa=xa(Jn,Er,br,tt),Ot=Or(Qn),$a=Nr(Ot),za=Rr(Ot),Xa=vr($a,za),Ha=Va(Jn,Xa,Ot),Ya=yr(Rt),Za=Tr(Rt),Qa=Ar(Mr(tt),tt,qa,Ha,Kn,_r(Ya,ja),Za),Ka=new WeakMap,Ja=async e=>{const t=await gr(e);Kn.push(t),Ka.set(e,t)},ei=sn({characterize:({call:e})=>()=>e("characterize"),encode:({call:e})=>(t,n)=>e("encode",{recordingId:t,timeslice:n}),record:({call:e})=>async(t,n,r)=>{await e("record",{recordingId:t,sampleRate:n,typedArrays:r},r.map(({buffer:s})=>s))}}),ti=e=>{const t=new Worker(e);return ei(t)},ni=`(()=>{var e={455:function(e,t){!function(e){"use strict";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,s=536870912,a=2*s,o=function(e,t){return function(r){var o=t.get(r),i=void 0===o?r.size:o<a?o+1:0;if(!r.has(i))return e(r,i);if(r.size<s){for(;r.has(i);)i=Math.floor(Math.random()*a);return e(r,i)}if(r.size>n)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,l=r(i),c=o(l,i),u=t(c);e.addUniqueNumber=u,e.generateUniqueNumber=c}(t)}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,r),a.exports}(()=>{"use strict";const e=-32603,t=-32602,n=-32601,s=(e,t)=>Object.assign(new Error(e),{status:t}),a=t=>s('The handler of the method called "'.concat(t,'" returned an unexpected result.'),e),o=(t,r)=>async o=>{let{data:{id:i,method:l,params:c}}=o;const u=r[l];try{if(void 0===u)throw(e=>s('The requested method called "'.concat(e,'" is not supported.'),n))(l);const r=void 0===c?u():u(c);if(void 0===r)throw(t=>s('The handler of the method called "'.concat(t,'" returned no required result.'),e))(l);const o=r instanceof Promise?await r:r;if(null===i){if(void 0!==o.result)throw a(l)}else{if(void 0===o.result)throw a(l);const{result:e,transferables:r=[]}=o;t.postMessage({id:i,result:e},r)}}catch(e){const{message:r,status:n=-32603}=e;t.postMessage({error:{code:n,message:r},id:i})}};var i=r(455);const l=new Map,c=(e,r,n)=>({...r,connect:t=>{let{port:n}=t;n.start();const s=e(n,r),a=(0,i.generateUniqueNumber)(l);return l.set(a,(()=>{s(),n.close(),l.delete(a)})),{result:a}},disconnect:e=>{let{portId:r}=e;const n=l.get(r);if(void 0===n)throw(e=>s('The specified parameter called "portId" with the given value "'.concat(e,'" does not identify a port connected to this worker.'),t))(r);return n(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),u=function(e,t){const r=c(u,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0),n=o(e,r);return e.addEventListener("message",n),()=>e.removeEventListener("message",n)},d=e=>e.reduce(((e,t)=>e+t.length),0),h=(e,t)=>{const r=[];let n=0;e:for(;n<t;){const t=e.length;for(let s=0;s<t;s+=1){const t=e[s];void 0===r[s]&&(r[s]=[]);const a=t.shift();if(void 0===a)break e;r[s].push(a),0===s&&(n+=a.length)}}if(n>t){const s=n-t;r.forEach(((t,r)=>{const n=t.pop(),a=n.length-s;t.push(n.subarray(0,a)),e[r].unshift(n.subarray(a))}))}return r},f=new Map,m=(e=>(t,r,n)=>{const s=e.get(t);if(void 0===s){const s={channelDataArrays:n.map((e=>[e])),isComplete:!0,sampleRate:r};return e.set(t,s),s}return s.channelDataArrays.forEach(((e,t)=>e.push(n[t]))),s})(f),p=((e,t)=>(r,n,s,a)=>{const o=s>>3,i="subsequent"===n?0:44,l=r.length,c=e(r[0]),u=new ArrayBuffer(c*l*o+i),d=new DataView(u);return"subsequent"!==n&&t(d,s,l,"complete"===n?c:Number.POSITIVE_INFINITY,a),r.forEach(((e,t)=>{let r=i+t*o;e.forEach((e=>{const t=e.length;for(let n=0;n<t;n+=1){const t=e[n];d.setInt16(r,t<0?32768*Math.max(-1,t):32767*Math.min(1,t),!0),r+=l*o}}))})),[u]})(d,((e,t,r,n,s)=>{const a=t>>3,o=Math.min(n*r*a,4294967251);e.setUint32(0,1380533830),e.setUint32(4,o+36,!0),e.setUint32(8,1463899717),e.setUint32(12,1718449184),e.setUint32(16,16,!0),e.setUint16(20,1,!0),e.setUint16(22,r,!0),e.setUint32(24,s,!0),e.setUint32(28,s*r*a,!0),e.setUint16(32,r*a,!0),e.setUint16(34,t,!0),e.setUint32(36,1684108385),e.setUint32(40,o,!0)})),v=new Map;u(self,{characterize:()=>({result:/^audio\\/wav$/}),encode:e=>{let{recordingId:t,timeslice:r}=e;const n=v.get(t);void 0!==n&&(v.delete(t),n.reject(new Error("Another request was made to initiate an encoding.")));const s=f.get(t);if(null!==r){if(void 0===s||d(s.channelDataArrays[0])*(1e3/s.sampleRate)<r)return new Promise(((e,n)=>{v.set(t,{reject:n,resolve:e,timeslice:r})}));const e=h(s.channelDataArrays,Math.ceil(r*(s.sampleRate/1e3))),n=p(e,s.isComplete?"initial":"subsequent",16,s.sampleRate);return s.isComplete=!1,{result:n,transferables:n}}if(void 0!==s){const e=p(s.channelDataArrays,s.isComplete?"complete":"subsequent",16,s.sampleRate);return f.delete(t),{result:e,transferables:e}}return{result:[],transferables:[]}},record:e=>{let{recordingId:t,sampleRate:r,typedArrays:n}=e;const s=m(t,r,n),a=v.get(t);if(void 0!==a&&d(s.channelDataArrays[0])*(1e3/r)>=a.timeslice){const e=h(s.channelDataArrays,Math.ceil(a.timeslice*(r/1e3))),n=p(e,s.isComplete?"initial":"subsequent",16,r);s.isComplete=!1,v.delete(t),a.resolve({result:n,transferables:n})}return{result:null}}})})()})();`,ri=new Blob([ni],{type:"application/javascript; charset=utf-8"}),er=URL.createObjectURL(ri),si=ti(er),oi=si.connect;URL.revokeObjectURL(er);function vi(e){return{isRecording:!1,mediaRecorder:null,audioChunks:[],maxRecordingTime:e,retries:0,searchByRecorded:!1,retriesQparam:{identifier:crypto.randomUUID(),samplems:e},recordingTimeout:null,stream:null,encoderRegistered:!1,async init(){try{this.encoderRegistered||(await Ja(await oi()),this.encoderRegistered=!0)}catch(t){console.log("Error registering encoder: "+t.message)}},async startRecording(){this.searchByRecorded=!0,ye.find("#search-results").innerHTML="",ye.find("#error-results").innerHTML="";try{this.stream&&this.stream.getTracks().forEach(t=>t.stop()),this.stream=await navigator.mediaDevices.getUserMedia({audio:!0}),this.mediaRecorder=new Qa(this.stream,{mimeType:"audio/wav"}),this.isRecording=!0,this.mediaRecorder.start(),this.recordingTimeout=setTimeout(()=>{this.stopRecording()},this.maxRecordingTime),this.mediaRecorder.addEventListener("dataavailable",t=>{this.audioChunks.push(t.data)}),this.mediaRecorder.addEventListener("stop",async()=>{const t=new Blob(this.audioChunks,{type:this.mediaRecorder.mimeType}),n=document.getElementById("search-recorded");n.setAttribute("hx-encoding","multipart/form-data"),n.setAttribute("hx-trigger","none");const r=new File([t],"audio.wav"),s=new FormData(n);s.append("audio",r),ye.ajax("POST",n.getAttribute("hx-post"),{values:{...this.retriesQparam,audio:s.get("audio")},event:this.afterRequest(),source:n})})}catch(t){console.log("Error accessing microphone: "+t.message)}},async stopRecording(){this.mediaRecorder&&this.isRecording&&(this.isRecording=!1,this.audioChunks=[],clearTimeout(this.recordingTimeout),this.mediaRecorder.stop(),this.stream.getTracks().forEach(t=>t.stop()))},afterRequest(){ye.on("htmx:afterRequest",t=>{if(this.searchByRecorded){if(t.detail.successful){this.resetRetries();return}t.detail.xhr.status===400&&(this.retries<3?(this.retries+=1,this.retriesQparam.samplems+=this.maxRecordingTime,this.startRecording()):(this.resetRetries(),ye.find("#error-results").innerHTML=t.detail.xhr.responseText))}})},resetRetries(){this.retries=0,this.searchByRecorded=!1,this.retriesQparam.identifier=crypto.randomUUID(),this.retriesQparam.samplems=this.maxRecordingTime}}}export{vi as a};
